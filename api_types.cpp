/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "api_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace api {

int _kTransactionTypeValues[] = {
  TT_Normal,
  TT_SmartDeploy,
  TT_SmartExecute,
  TT_SmartState
};
const char* _kTransactionTypeNames[] = {
  "TT_Normal",
  "TT_SmartDeploy",
  "TT_SmartExecute",
  "TT_SmartState"
};
const std::map<int, const char*> _TransactionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTransactionTypeValues, _kTransactionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TransactionType val) {
  std::map<int, const char*>::const_iterator it = _TransactionType_VALUES_TO_NAMES.find(val);
  if (it != _TransactionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kSmartOperationStateValues[] = {
  SOS_Pending,
  SOS_Success,
  SOS_Failed
};
const char* _kSmartOperationStateNames[] = {
  "SOS_Pending",
  "SOS_Success",
  "SOS_Failed"
};
const std::map<int, const char*> _SmartOperationState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kSmartOperationStateValues, _kSmartOperationStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const SmartOperationState val) {
  std::map<int, const char*>::const_iterator it = _SmartOperationState_VALUES_TO_NAMES.find(val);
  if (it != _SmartOperationState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTransactionStateValues[] = {
  INVALID,
  VALID,
  INPROGRESS
};
const char* _kTransactionStateNames[] = {
  "INVALID",
  "VALID",
  "INPROGRESS"
};
const std::map<int, const char*> _TransactionState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTransactionStateValues, _kTransactionStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TransactionState val) {
  std::map<int, const char*>::const_iterator it = _TransactionState_VALUES_TO_NAMES.find(val);
  if (it != _TransactionState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTokenStandartValues[] = {
  NotAToken,
  CreditsBasic,
  CreditsExtended
};
const char* _kTokenStandartNames[] = {
  "NotAToken",
  "CreditsBasic",
  "CreditsExtended"
};
const std::map<int, const char*> _TokenStandart_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTokenStandartValues, _kTokenStandartNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TokenStandart val) {
  std::map<int, const char*>::const_iterator it = _TokenStandart_VALUES_TO_NAMES.find(val);
  if (it != _TokenStandart_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTokensListSortFieldValues[] = {
  TL_Code,
  TL_Name,
  TL_Address,
  TL_TotalSupply,
  TL_HoldersCount,
  TL_TransfersCount,
  TL_TransactionsCount
};
const char* _kTokensListSortFieldNames[] = {
  "TL_Code",
  "TL_Name",
  "TL_Address",
  "TL_TotalSupply",
  "TL_HoldersCount",
  "TL_TransfersCount",
  "TL_TransactionsCount"
};
const std::map<int, const char*> _TokensListSortField_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTokensListSortFieldValues, _kTokensListSortFieldNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TokensListSortField val) {
  std::map<int, const char*>::const_iterator it = _TokensListSortField_VALUES_TO_NAMES.find(val);
  if (it != _TokensListSortField_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTokenHoldersSortFieldValues[] = {
  TH_Balance,
  TH_TransfersCount
};
const char* _kTokenHoldersSortFieldNames[] = {
  "TH_Balance",
  "TH_TransfersCount"
};
const std::map<int, const char*> _TokenHoldersSortField_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTokenHoldersSortFieldValues, _kTokenHoldersSortFieldNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TokenHoldersSortField val) {
  std::map<int, const char*>::const_iterator it = _TokenHoldersSortField_VALUES_TO_NAMES.find(val);
  if (it != _TokenHoldersSortField_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


Amount::~Amount() throw() {
}


void Amount::__set_integral(const int32_t val) {
  this->integral = val;
}

void Amount::__set_fraction(const int64_t val) {
  this->fraction = val;
}
std::ostream& operator<<(std::ostream& out, const Amount& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Amount::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_integral = false;
  bool isset_fraction = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->integral);
          isset_integral = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fraction);
          isset_fraction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_integral)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fraction)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Amount::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Amount");

  xfer += oprot->writeFieldBegin("integral", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->integral);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fraction", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->fraction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Amount &a, Amount &b) {
  using ::std::swap;
  swap(a.integral, b.integral);
  swap(a.fraction, b.fraction);
}

Amount::Amount(const Amount& other0) {
  integral = other0.integral;
  fraction = other0.fraction;
}
Amount::Amount( Amount&& other1) {
  integral = std::move(other1.integral);
  fraction = std::move(other1.fraction);
}
Amount& Amount::operator=(const Amount& other2) {
  integral = other2.integral;
  fraction = other2.fraction;
  return *this;
}
Amount& Amount::operator=(Amount&& other3) {
  integral = std::move(other3.integral);
  fraction = std::move(other3.fraction);
  return *this;
}
void Amount::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Amount(";
  out << "integral=" << to_string(integral);
  out << ", " << "fraction=" << to_string(fraction);
  out << ")";
}


AmountCommission::~AmountCommission() throw() {
}


void AmountCommission::__set_commission(const int16_t val) {
  this->commission = val;
}
std::ostream& operator<<(std::ostream& out, const AmountCommission& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AmountCommission::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_commission = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->commission);
          isset_commission = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_commission)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AmountCommission::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AmountCommission");

  xfer += oprot->writeFieldBegin("commission", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->commission);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AmountCommission &a, AmountCommission &b) {
  using ::std::swap;
  swap(a.commission, b.commission);
}

AmountCommission::AmountCommission(const AmountCommission& other4) {
  commission = other4.commission;
}
AmountCommission::AmountCommission( AmountCommission&& other5) {
  commission = std::move(other5.commission);
}
AmountCommission& AmountCommission::operator=(const AmountCommission& other6) {
  commission = other6.commission;
  return *this;
}
AmountCommission& AmountCommission::operator=(AmountCommission&& other7) {
  commission = std::move(other7.commission);
  return *this;
}
void AmountCommission::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AmountCommission(";
  out << "commission=" << to_string(commission);
  out << ")";
}


CumulativeAmount::~CumulativeAmount() throw() {
}


void CumulativeAmount::__set_integral(const int64_t val) {
  this->integral = val;
}

void CumulativeAmount::__set_fraction(const int64_t val) {
  this->fraction = val;
}
std::ostream& operator<<(std::ostream& out, const CumulativeAmount& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CumulativeAmount::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_integral = false;
  bool isset_fraction = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->integral);
          isset_integral = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fraction);
          isset_fraction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_integral)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fraction)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CumulativeAmount::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CumulativeAmount");

  xfer += oprot->writeFieldBegin("integral", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->integral);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fraction", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->fraction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CumulativeAmount &a, CumulativeAmount &b) {
  using ::std::swap;
  swap(a.integral, b.integral);
  swap(a.fraction, b.fraction);
}

CumulativeAmount::CumulativeAmount(const CumulativeAmount& other8) {
  integral = other8.integral;
  fraction = other8.fraction;
}
CumulativeAmount::CumulativeAmount( CumulativeAmount&& other9) {
  integral = std::move(other9.integral);
  fraction = std::move(other9.fraction);
}
CumulativeAmount& CumulativeAmount::operator=(const CumulativeAmount& other10) {
  integral = other10.integral;
  fraction = other10.fraction;
  return *this;
}
CumulativeAmount& CumulativeAmount::operator=(CumulativeAmount&& other11) {
  integral = std::move(other11.integral);
  fraction = std::move(other11.fraction);
  return *this;
}
void CumulativeAmount::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CumulativeAmount(";
  out << "integral=" << to_string(integral);
  out << ", " << "fraction=" << to_string(fraction);
  out << ")";
}


SmartContractDeploy::~SmartContractDeploy() throw() {
}


void SmartContractDeploy::__set_sourceCode(const std::string& val) {
  this->sourceCode = val;
}

void SmartContractDeploy::__set_byteCodeObjects(const std::vector< ::general::ByteCodeObject> & val) {
  this->byteCodeObjects = val;
}

void SmartContractDeploy::__set_hashState(const std::string& val) {
  this->hashState = val;
}

void SmartContractDeploy::__set_tokenStandart(const TokenStandart val) {
  this->tokenStandart = val;
}
std::ostream& operator<<(std::ostream& out, const SmartContractDeploy& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContractDeploy::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sourceCode);
          this->__isset.sourceCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->byteCodeObjects.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->byteCodeObjects.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->byteCodeObjects[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.byteCodeObjects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hashState);
          this->__isset.hashState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast17;
          xfer += iprot->readI32(ecast17);
          this->tokenStandart = (TokenStandart)ecast17;
          this->__isset.tokenStandart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartContractDeploy::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContractDeploy");

  xfer += oprot->writeFieldBegin("sourceCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sourceCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteCodeObjects", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->byteCodeObjects.size()));
    std::vector< ::general::ByteCodeObject> ::const_iterator _iter18;
    for (_iter18 = this->byteCodeObjects.begin(); _iter18 != this->byteCodeObjects.end(); ++_iter18)
    {
      xfer += (*_iter18).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hashState", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->hashState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tokenStandart", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->tokenStandart);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContractDeploy &a, SmartContractDeploy &b) {
  using ::std::swap;
  swap(a.sourceCode, b.sourceCode);
  swap(a.byteCodeObjects, b.byteCodeObjects);
  swap(a.hashState, b.hashState);
  swap(a.tokenStandart, b.tokenStandart);
  swap(a.__isset, b.__isset);
}

SmartContractDeploy::SmartContractDeploy(const SmartContractDeploy& other19) {
  sourceCode = other19.sourceCode;
  byteCodeObjects = other19.byteCodeObjects;
  hashState = other19.hashState;
  tokenStandart = other19.tokenStandart;
  __isset = other19.__isset;
}
SmartContractDeploy::SmartContractDeploy( SmartContractDeploy&& other20) {
  sourceCode = std::move(other20.sourceCode);
  byteCodeObjects = std::move(other20.byteCodeObjects);
  hashState = std::move(other20.hashState);
  tokenStandart = std::move(other20.tokenStandart);
  __isset = std::move(other20.__isset);
}
SmartContractDeploy& SmartContractDeploy::operator=(const SmartContractDeploy& other21) {
  sourceCode = other21.sourceCode;
  byteCodeObjects = other21.byteCodeObjects;
  hashState = other21.hashState;
  tokenStandart = other21.tokenStandart;
  __isset = other21.__isset;
  return *this;
}
SmartContractDeploy& SmartContractDeploy::operator=(SmartContractDeploy&& other22) {
  sourceCode = std::move(other22.sourceCode);
  byteCodeObjects = std::move(other22.byteCodeObjects);
  hashState = std::move(other22.hashState);
  tokenStandart = std::move(other22.tokenStandart);
  __isset = std::move(other22.__isset);
  return *this;
}
void SmartContractDeploy::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContractDeploy(";
  out << "sourceCode=" << to_string(sourceCode);
  out << ", " << "byteCodeObjects=" << to_string(byteCodeObjects);
  out << ", " << "hashState=" << to_string(hashState);
  out << ", " << "tokenStandart=" << to_string(tokenStandart);
  out << ")";
}


SmartContract::~SmartContract() throw() {
}


void SmartContract::__set_address(const Address& val) {
  this->address = val;
}

void SmartContract::__set_deployer(const Address& val) {
  this->deployer = val;
}

void SmartContract::__set_smartContractDeploy(const SmartContractDeploy& val) {
  this->smartContractDeploy = val;
}

void SmartContract::__set_objectState(const std::string& val) {
  this->objectState = val;
}

void SmartContract::__set_createTime(const Time val) {
  this->createTime = val;
}

void SmartContract::__set_transactionsCount(const int32_t val) {
  this->transactionsCount = val;
}
std::ostream& operator<<(std::ostream& out, const SmartContract& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContract::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_address = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->address);
          isset_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->deployer);
          this->__isset.deployer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->smartContractDeploy.read(iprot);
          this->__isset.smartContractDeploy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->objectState);
          this->__isset.objectState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->transactionsCount);
          this->__isset.transactionsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_address)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SmartContract::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContract");

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->address);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deployer", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->deployer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("smartContractDeploy", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->smartContractDeploy.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objectState", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->objectState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactionsCount", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->transactionsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContract &a, SmartContract &b) {
  using ::std::swap;
  swap(a.address, b.address);
  swap(a.deployer, b.deployer);
  swap(a.smartContractDeploy, b.smartContractDeploy);
  swap(a.objectState, b.objectState);
  swap(a.createTime, b.createTime);
  swap(a.transactionsCount, b.transactionsCount);
  swap(a.__isset, b.__isset);
}

SmartContract::SmartContract(const SmartContract& other23) {
  address = other23.address;
  deployer = other23.deployer;
  smartContractDeploy = other23.smartContractDeploy;
  objectState = other23.objectState;
  createTime = other23.createTime;
  transactionsCount = other23.transactionsCount;
  __isset = other23.__isset;
}
SmartContract::SmartContract( SmartContract&& other24) {
  address = std::move(other24.address);
  deployer = std::move(other24.deployer);
  smartContractDeploy = std::move(other24.smartContractDeploy);
  objectState = std::move(other24.objectState);
  createTime = std::move(other24.createTime);
  transactionsCount = std::move(other24.transactionsCount);
  __isset = std::move(other24.__isset);
}
SmartContract& SmartContract::operator=(const SmartContract& other25) {
  address = other25.address;
  deployer = other25.deployer;
  smartContractDeploy = other25.smartContractDeploy;
  objectState = other25.objectState;
  createTime = other25.createTime;
  transactionsCount = other25.transactionsCount;
  __isset = other25.__isset;
  return *this;
}
SmartContract& SmartContract::operator=(SmartContract&& other26) {
  address = std::move(other26.address);
  deployer = std::move(other26.deployer);
  smartContractDeploy = std::move(other26.smartContractDeploy);
  objectState = std::move(other26.objectState);
  createTime = std::move(other26.createTime);
  transactionsCount = std::move(other26.transactionsCount);
  __isset = std::move(other26.__isset);
  return *this;
}
void SmartContract::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContract(";
  out << "address=" << to_string(address);
  out << ", " << "deployer=" << to_string(deployer);
  out << ", " << "smartContractDeploy=" << to_string(smartContractDeploy);
  out << ", " << "objectState=" << to_string(objectState);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "transactionsCount=" << to_string(transactionsCount);
  out << ")";
}


SmartContractInvocation::~SmartContractInvocation() throw() {
}


void SmartContractInvocation::__set_method(const std::string& val) {
  this->method = val;
}

void SmartContractInvocation::__set_params(const std::vector< ::general::Variant> & val) {
  this->params = val;
}

void SmartContractInvocation::__set_forgetNewState(const bool val) {
  this->forgetNewState = val;
}

void SmartContractInvocation::__set_smartContractDeploy(const SmartContractDeploy& val) {
  this->smartContractDeploy = val;
__isset.smartContractDeploy = true;
}
std::ostream& operator<<(std::ostream& out, const SmartContractInvocation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContractInvocation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method);
          this->__isset.method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->params.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->params.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += this->params[_i31].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->forgetNewState);
          this->__isset.forgetNewState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->smartContractDeploy.read(iprot);
          this->__isset.smartContractDeploy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartContractInvocation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContractInvocation");

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->params.size()));
    std::vector< ::general::Variant> ::const_iterator _iter32;
    for (_iter32 = this->params.begin(); _iter32 != this->params.end(); ++_iter32)
    {
      xfer += (*_iter32).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("forgetNewState", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->forgetNewState);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.smartContractDeploy) {
    xfer += oprot->writeFieldBegin("smartContractDeploy", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->smartContractDeploy.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContractInvocation &a, SmartContractInvocation &b) {
  using ::std::swap;
  swap(a.method, b.method);
  swap(a.params, b.params);
  swap(a.forgetNewState, b.forgetNewState);
  swap(a.smartContractDeploy, b.smartContractDeploy);
  swap(a.__isset, b.__isset);
}

SmartContractInvocation::SmartContractInvocation(const SmartContractInvocation& other33) {
  method = other33.method;
  params = other33.params;
  forgetNewState = other33.forgetNewState;
  smartContractDeploy = other33.smartContractDeploy;
  __isset = other33.__isset;
}
SmartContractInvocation::SmartContractInvocation( SmartContractInvocation&& other34) {
  method = std::move(other34.method);
  params = std::move(other34.params);
  forgetNewState = std::move(other34.forgetNewState);
  smartContractDeploy = std::move(other34.smartContractDeploy);
  __isset = std::move(other34.__isset);
}
SmartContractInvocation& SmartContractInvocation::operator=(const SmartContractInvocation& other35) {
  method = other35.method;
  params = other35.params;
  forgetNewState = other35.forgetNewState;
  smartContractDeploy = other35.smartContractDeploy;
  __isset = other35.__isset;
  return *this;
}
SmartContractInvocation& SmartContractInvocation::operator=(SmartContractInvocation&& other36) {
  method = std::move(other36.method);
  params = std::move(other36.params);
  forgetNewState = std::move(other36.forgetNewState);
  smartContractDeploy = std::move(other36.smartContractDeploy);
  __isset = std::move(other36.__isset);
  return *this;
}
void SmartContractInvocation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContractInvocation(";
  out << "method=" << to_string(method);
  out << ", " << "params=" << to_string(params);
  out << ", " << "forgetNewState=" << to_string(forgetNewState);
  out << ", " << "smartContractDeploy="; (__isset.smartContractDeploy ? (out << to_string(smartContractDeploy)) : (out << "<null>"));
  out << ")";
}


TransactionId::~TransactionId() throw() {
}


void TransactionId::__set_poolHash(const PoolHash& val) {
  this->poolHash = val;
}

void TransactionId::__set_index(const int32_t val) {
  this->index = val;
}
std::ostream& operator<<(std::ostream& out, const TransactionId& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TransactionId::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->poolHash);
          this->__isset.poolHash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TransactionId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TransactionId");

  xfer += oprot->writeFieldBegin("poolHash", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->poolHash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransactionId &a, TransactionId &b) {
  using ::std::swap;
  swap(a.poolHash, b.poolHash);
  swap(a.index, b.index);
  swap(a.__isset, b.__isset);
}

TransactionId::TransactionId(const TransactionId& other37) {
  poolHash = other37.poolHash;
  index = other37.index;
  __isset = other37.__isset;
}
TransactionId::TransactionId( TransactionId&& other38) {
  poolHash = std::move(other38.poolHash);
  index = std::move(other38.index);
  __isset = std::move(other38.__isset);
}
TransactionId& TransactionId::operator=(const TransactionId& other39) {
  poolHash = other39.poolHash;
  index = other39.index;
  __isset = other39.__isset;
  return *this;
}
TransactionId& TransactionId::operator=(TransactionId&& other40) {
  poolHash = std::move(other40.poolHash);
  index = std::move(other40.index);
  __isset = std::move(other40.__isset);
  return *this;
}
void TransactionId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TransactionId(";
  out << "poolHash=" << to_string(poolHash);
  out << ", " << "index=" << to_string(index);
  out << ")";
}


TokenDeployTransInfo::~TokenDeployTransInfo() throw() {
}


void TokenDeployTransInfo::__set_name(const std::string& val) {
  this->name = val;
}

void TokenDeployTransInfo::__set_code(const TokenCode& val) {
  this->code = val;
}

void TokenDeployTransInfo::__set_standart(const TokenStandart val) {
  this->standart = val;
}

void TokenDeployTransInfo::__set_state(const SmartOperationState val) {
  this->state = val;
}

void TokenDeployTransInfo::__set_stateTransaction(const TransactionId& val) {
  this->stateTransaction = val;
__isset.stateTransaction = true;
}
std::ostream& operator<<(std::ostream& out, const TokenDeployTransInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TokenDeployTransInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast41;
          xfer += iprot->readI32(ecast41);
          this->standart = (TokenStandart)ecast41;
          this->__isset.standart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast42;
          xfer += iprot->readI32(ecast42);
          this->state = (SmartOperationState)ecast42;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stateTransaction.read(iprot);
          this->__isset.stateTransaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TokenDeployTransInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TokenDeployTransInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("standart", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->standart);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stateTransaction) {
    xfer += oprot->writeFieldBegin("stateTransaction", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->stateTransaction.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenDeployTransInfo &a, TokenDeployTransInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.code, b.code);
  swap(a.standart, b.standart);
  swap(a.state, b.state);
  swap(a.stateTransaction, b.stateTransaction);
  swap(a.__isset, b.__isset);
}

TokenDeployTransInfo::TokenDeployTransInfo(const TokenDeployTransInfo& other43) {
  name = other43.name;
  code = other43.code;
  standart = other43.standart;
  state = other43.state;
  stateTransaction = other43.stateTransaction;
  __isset = other43.__isset;
}
TokenDeployTransInfo::TokenDeployTransInfo( TokenDeployTransInfo&& other44) {
  name = std::move(other44.name);
  code = std::move(other44.code);
  standart = std::move(other44.standart);
  state = std::move(other44.state);
  stateTransaction = std::move(other44.stateTransaction);
  __isset = std::move(other44.__isset);
}
TokenDeployTransInfo& TokenDeployTransInfo::operator=(const TokenDeployTransInfo& other45) {
  name = other45.name;
  code = other45.code;
  standart = other45.standart;
  state = other45.state;
  stateTransaction = other45.stateTransaction;
  __isset = other45.__isset;
  return *this;
}
TokenDeployTransInfo& TokenDeployTransInfo::operator=(TokenDeployTransInfo&& other46) {
  name = std::move(other46.name);
  code = std::move(other46.code);
  standart = std::move(other46.standart);
  state = std::move(other46.state);
  stateTransaction = std::move(other46.stateTransaction);
  __isset = std::move(other46.__isset);
  return *this;
}
void TokenDeployTransInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TokenDeployTransInfo(";
  out << "name=" << to_string(name);
  out << ", " << "code=" << to_string(code);
  out << ", " << "standart=" << to_string(standart);
  out << ", " << "state=" << to_string(state);
  out << ", " << "stateTransaction="; (__isset.stateTransaction ? (out << to_string(stateTransaction)) : (out << "<null>"));
  out << ")";
}


TokenTransferTransInfo::~TokenTransferTransInfo() throw() {
}


void TokenTransferTransInfo::__set_code(const TokenCode& val) {
  this->code = val;
}

void TokenTransferTransInfo::__set_sender(const Address& val) {
  this->sender = val;
}

void TokenTransferTransInfo::__set_receiver(const Address& val) {
  this->receiver = val;
}

void TokenTransferTransInfo::__set_amount(const TokenAmount& val) {
  this->amount = val;
}

void TokenTransferTransInfo::__set_state(const SmartOperationState val) {
  this->state = val;
}

void TokenTransferTransInfo::__set_stateTransaction(const TransactionId& val) {
  this->stateTransaction = val;
__isset.stateTransaction = true;
}

void TokenTransferTransInfo::__set_transferSuccess(const bool val) {
  this->transferSuccess = val;
__isset.transferSuccess = true;
}
std::ostream& operator<<(std::ostream& out, const TokenTransferTransInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TokenTransferTransInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sender);
          this->__isset.sender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->receiver);
          this->__isset.receiver = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->amount);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast47;
          xfer += iprot->readI32(ecast47);
          this->state = (SmartOperationState)ecast47;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stateTransaction.read(iprot);
          this->__isset.stateTransaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->transferSuccess);
          this->__isset.transferSuccess = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TokenTransferTransInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TokenTransferTransInfo");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sender", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->sender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("receiver", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->receiver);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->amount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stateTransaction) {
    xfer += oprot->writeFieldBegin("stateTransaction", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->stateTransaction.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.transferSuccess) {
    xfer += oprot->writeFieldBegin("transferSuccess", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->transferSuccess);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenTransferTransInfo &a, TokenTransferTransInfo &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.sender, b.sender);
  swap(a.receiver, b.receiver);
  swap(a.amount, b.amount);
  swap(a.state, b.state);
  swap(a.stateTransaction, b.stateTransaction);
  swap(a.transferSuccess, b.transferSuccess);
  swap(a.__isset, b.__isset);
}

TokenTransferTransInfo::TokenTransferTransInfo(const TokenTransferTransInfo& other48) {
  code = other48.code;
  sender = other48.sender;
  receiver = other48.receiver;
  amount = other48.amount;
  state = other48.state;
  stateTransaction = other48.stateTransaction;
  transferSuccess = other48.transferSuccess;
  __isset = other48.__isset;
}
TokenTransferTransInfo::TokenTransferTransInfo( TokenTransferTransInfo&& other49) {
  code = std::move(other49.code);
  sender = std::move(other49.sender);
  receiver = std::move(other49.receiver);
  amount = std::move(other49.amount);
  state = std::move(other49.state);
  stateTransaction = std::move(other49.stateTransaction);
  transferSuccess = std::move(other49.transferSuccess);
  __isset = std::move(other49.__isset);
}
TokenTransferTransInfo& TokenTransferTransInfo::operator=(const TokenTransferTransInfo& other50) {
  code = other50.code;
  sender = other50.sender;
  receiver = other50.receiver;
  amount = other50.amount;
  state = other50.state;
  stateTransaction = other50.stateTransaction;
  transferSuccess = other50.transferSuccess;
  __isset = other50.__isset;
  return *this;
}
TokenTransferTransInfo& TokenTransferTransInfo::operator=(TokenTransferTransInfo&& other51) {
  code = std::move(other51.code);
  sender = std::move(other51.sender);
  receiver = std::move(other51.receiver);
  amount = std::move(other51.amount);
  state = std::move(other51.state);
  stateTransaction = std::move(other51.stateTransaction);
  transferSuccess = std::move(other51.transferSuccess);
  __isset = std::move(other51.__isset);
  return *this;
}
void TokenTransferTransInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TokenTransferTransInfo(";
  out << "code=" << to_string(code);
  out << ", " << "sender=" << to_string(sender);
  out << ", " << "receiver=" << to_string(receiver);
  out << ", " << "amount=" << to_string(amount);
  out << ", " << "state=" << to_string(state);
  out << ", " << "stateTransaction="; (__isset.stateTransaction ? (out << to_string(stateTransaction)) : (out << "<null>"));
  out << ", " << "transferSuccess="; (__isset.transferSuccess ? (out << to_string(transferSuccess)) : (out << "<null>"));
  out << ")";
}


SmartDeployTransInfo::~SmartDeployTransInfo() throw() {
}


void SmartDeployTransInfo::__set_state(const SmartOperationState val) {
  this->state = val;
}

void SmartDeployTransInfo::__set_stateTransaction(const TransactionId& val) {
  this->stateTransaction = val;
__isset.stateTransaction = true;
}
std::ostream& operator<<(std::ostream& out, const SmartDeployTransInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartDeployTransInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast52;
          xfer += iprot->readI32(ecast52);
          this->state = (SmartOperationState)ecast52;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stateTransaction.read(iprot);
          this->__isset.stateTransaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartDeployTransInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartDeployTransInfo");

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stateTransaction) {
    xfer += oprot->writeFieldBegin("stateTransaction", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->stateTransaction.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartDeployTransInfo &a, SmartDeployTransInfo &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.stateTransaction, b.stateTransaction);
  swap(a.__isset, b.__isset);
}

SmartDeployTransInfo::SmartDeployTransInfo(const SmartDeployTransInfo& other53) {
  state = other53.state;
  stateTransaction = other53.stateTransaction;
  __isset = other53.__isset;
}
SmartDeployTransInfo::SmartDeployTransInfo( SmartDeployTransInfo&& other54) {
  state = std::move(other54.state);
  stateTransaction = std::move(other54.stateTransaction);
  __isset = std::move(other54.__isset);
}
SmartDeployTransInfo& SmartDeployTransInfo::operator=(const SmartDeployTransInfo& other55) {
  state = other55.state;
  stateTransaction = other55.stateTransaction;
  __isset = other55.__isset;
  return *this;
}
SmartDeployTransInfo& SmartDeployTransInfo::operator=(SmartDeployTransInfo&& other56) {
  state = std::move(other56.state);
  stateTransaction = std::move(other56.stateTransaction);
  __isset = std::move(other56.__isset);
  return *this;
}
void SmartDeployTransInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartDeployTransInfo(";
  out << "state=" << to_string(state);
  out << ", " << "stateTransaction="; (__isset.stateTransaction ? (out << to_string(stateTransaction)) : (out << "<null>"));
  out << ")";
}


SmartExecutionTransInfo::~SmartExecutionTransInfo() throw() {
}


void SmartExecutionTransInfo::__set_method(const std::string& val) {
  this->method = val;
}

void SmartExecutionTransInfo::__set_params(const std::vector< ::general::Variant> & val) {
  this->params = val;
}

void SmartExecutionTransInfo::__set_state(const SmartOperationState val) {
  this->state = val;
}

void SmartExecutionTransInfo::__set_stateTransaction(const TransactionId& val) {
  this->stateTransaction = val;
__isset.stateTransaction = true;
}
std::ostream& operator<<(std::ostream& out, const SmartExecutionTransInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartExecutionTransInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method);
          this->__isset.method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->params.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readListBegin(_etype60, _size57);
            this->params.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += this->params[_i61].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast62;
          xfer += iprot->readI32(ecast62);
          this->state = (SmartOperationState)ecast62;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stateTransaction.read(iprot);
          this->__isset.stateTransaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartExecutionTransInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartExecutionTransInfo");

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->params.size()));
    std::vector< ::general::Variant> ::const_iterator _iter63;
    for (_iter63 = this->params.begin(); _iter63 != this->params.end(); ++_iter63)
    {
      xfer += (*_iter63).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stateTransaction) {
    xfer += oprot->writeFieldBegin("stateTransaction", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->stateTransaction.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartExecutionTransInfo &a, SmartExecutionTransInfo &b) {
  using ::std::swap;
  swap(a.method, b.method);
  swap(a.params, b.params);
  swap(a.state, b.state);
  swap(a.stateTransaction, b.stateTransaction);
  swap(a.__isset, b.__isset);
}

SmartExecutionTransInfo::SmartExecutionTransInfo(const SmartExecutionTransInfo& other64) {
  method = other64.method;
  params = other64.params;
  state = other64.state;
  stateTransaction = other64.stateTransaction;
  __isset = other64.__isset;
}
SmartExecutionTransInfo::SmartExecutionTransInfo( SmartExecutionTransInfo&& other65) {
  method = std::move(other65.method);
  params = std::move(other65.params);
  state = std::move(other65.state);
  stateTransaction = std::move(other65.stateTransaction);
  __isset = std::move(other65.__isset);
}
SmartExecutionTransInfo& SmartExecutionTransInfo::operator=(const SmartExecutionTransInfo& other66) {
  method = other66.method;
  params = other66.params;
  state = other66.state;
  stateTransaction = other66.stateTransaction;
  __isset = other66.__isset;
  return *this;
}
SmartExecutionTransInfo& SmartExecutionTransInfo::operator=(SmartExecutionTransInfo&& other67) {
  method = std::move(other67.method);
  params = std::move(other67.params);
  state = std::move(other67.state);
  stateTransaction = std::move(other67.stateTransaction);
  __isset = std::move(other67.__isset);
  return *this;
}
void SmartExecutionTransInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartExecutionTransInfo(";
  out << "method=" << to_string(method);
  out << ", " << "params=" << to_string(params);
  out << ", " << "state=" << to_string(state);
  out << ", " << "stateTransaction="; (__isset.stateTransaction ? (out << to_string(stateTransaction)) : (out << "<null>"));
  out << ")";
}


SmartStateTransInfo::~SmartStateTransInfo() throw() {
}


void SmartStateTransInfo::__set_success(const bool val) {
  this->success = val;
}

void SmartStateTransInfo::__set_executionFee(const Amount& val) {
  this->executionFee = val;
}

void SmartStateTransInfo::__set_returnValue(const  ::general::Variant& val) {
  this->returnValue = val;
__isset.returnValue = true;
}

void SmartStateTransInfo::__set_startTransaction(const TransactionId& val) {
  this->startTransaction = val;
}
std::ostream& operator<<(std::ostream& out, const SmartStateTransInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartStateTransInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->executionFee.read(iprot);
          this->__isset.executionFee = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->returnValue.read(iprot);
          this->__isset.returnValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->startTransaction.read(iprot);
          this->__isset.startTransaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartStateTransInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartStateTransInfo");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("executionFee", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->executionFee.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.returnValue) {
    xfer += oprot->writeFieldBegin("returnValue", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->returnValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("startTransaction", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->startTransaction.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartStateTransInfo &a, SmartStateTransInfo &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.executionFee, b.executionFee);
  swap(a.returnValue, b.returnValue);
  swap(a.startTransaction, b.startTransaction);
  swap(a.__isset, b.__isset);
}

SmartStateTransInfo::SmartStateTransInfo(const SmartStateTransInfo& other68) {
  success = other68.success;
  executionFee = other68.executionFee;
  returnValue = other68.returnValue;
  startTransaction = other68.startTransaction;
  __isset = other68.__isset;
}
SmartStateTransInfo::SmartStateTransInfo( SmartStateTransInfo&& other69) {
  success = std::move(other69.success);
  executionFee = std::move(other69.executionFee);
  returnValue = std::move(other69.returnValue);
  startTransaction = std::move(other69.startTransaction);
  __isset = std::move(other69.__isset);
}
SmartStateTransInfo& SmartStateTransInfo::operator=(const SmartStateTransInfo& other70) {
  success = other70.success;
  executionFee = other70.executionFee;
  returnValue = other70.returnValue;
  startTransaction = other70.startTransaction;
  __isset = other70.__isset;
  return *this;
}
SmartStateTransInfo& SmartStateTransInfo::operator=(SmartStateTransInfo&& other71) {
  success = std::move(other71.success);
  executionFee = std::move(other71.executionFee);
  returnValue = std::move(other71.returnValue);
  startTransaction = std::move(other71.startTransaction);
  __isset = std::move(other71.__isset);
  return *this;
}
void SmartStateTransInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartStateTransInfo(";
  out << "success=" << to_string(success);
  out << ", " << "executionFee=" << to_string(executionFee);
  out << ", " << "returnValue="; (__isset.returnValue ? (out << to_string(returnValue)) : (out << "<null>"));
  out << ", " << "startTransaction=" << to_string(startTransaction);
  out << ")";
}


SmartTransInfo::~SmartTransInfo() throw() {
}


void SmartTransInfo::__set_v_tokenDeploy(const TokenDeployTransInfo& val) {
  this->v_tokenDeploy = val;
__isset.v_tokenDeploy = true;
}

void SmartTransInfo::__set_v_tokenTransfer(const TokenTransferTransInfo& val) {
  this->v_tokenTransfer = val;
__isset.v_tokenTransfer = true;
}

void SmartTransInfo::__set_v_smartDeploy(const SmartDeployTransInfo& val) {
  this->v_smartDeploy = val;
__isset.v_smartDeploy = true;
}

void SmartTransInfo::__set_v_smartExecution(const SmartExecutionTransInfo& val) {
  this->v_smartExecution = val;
__isset.v_smartExecution = true;
}

void SmartTransInfo::__set_v_smartState(const SmartStateTransInfo& val) {
  this->v_smartState = val;
__isset.v_smartState = true;
}
std::ostream& operator<<(std::ostream& out, const SmartTransInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartTransInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_tokenDeploy.read(iprot);
          this->__isset.v_tokenDeploy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_tokenTransfer.read(iprot);
          this->__isset.v_tokenTransfer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_smartDeploy.read(iprot);
          this->__isset.v_smartDeploy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_smartExecution.read(iprot);
          this->__isset.v_smartExecution = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_smartState.read(iprot);
          this->__isset.v_smartState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartTransInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartTransInfo");

  if (this->__isset.v_tokenDeploy) {
    xfer += oprot->writeFieldBegin("v_tokenDeploy", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->v_tokenDeploy.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_tokenTransfer) {
    xfer += oprot->writeFieldBegin("v_tokenTransfer", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->v_tokenTransfer.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_smartDeploy) {
    xfer += oprot->writeFieldBegin("v_smartDeploy", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->v_smartDeploy.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_smartExecution) {
    xfer += oprot->writeFieldBegin("v_smartExecution", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->v_smartExecution.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_smartState) {
    xfer += oprot->writeFieldBegin("v_smartState", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->v_smartState.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartTransInfo &a, SmartTransInfo &b) {
  using ::std::swap;
  swap(a.v_tokenDeploy, b.v_tokenDeploy);
  swap(a.v_tokenTransfer, b.v_tokenTransfer);
  swap(a.v_smartDeploy, b.v_smartDeploy);
  swap(a.v_smartExecution, b.v_smartExecution);
  swap(a.v_smartState, b.v_smartState);
  swap(a.__isset, b.__isset);
}

SmartTransInfo::SmartTransInfo(const SmartTransInfo& other72) {
  v_tokenDeploy = other72.v_tokenDeploy;
  v_tokenTransfer = other72.v_tokenTransfer;
  v_smartDeploy = other72.v_smartDeploy;
  v_smartExecution = other72.v_smartExecution;
  v_smartState = other72.v_smartState;
  __isset = other72.__isset;
}
SmartTransInfo::SmartTransInfo( SmartTransInfo&& other73) {
  v_tokenDeploy = std::move(other73.v_tokenDeploy);
  v_tokenTransfer = std::move(other73.v_tokenTransfer);
  v_smartDeploy = std::move(other73.v_smartDeploy);
  v_smartExecution = std::move(other73.v_smartExecution);
  v_smartState = std::move(other73.v_smartState);
  __isset = std::move(other73.__isset);
}
SmartTransInfo& SmartTransInfo::operator=(const SmartTransInfo& other74) {
  v_tokenDeploy = other74.v_tokenDeploy;
  v_tokenTransfer = other74.v_tokenTransfer;
  v_smartDeploy = other74.v_smartDeploy;
  v_smartExecution = other74.v_smartExecution;
  v_smartState = other74.v_smartState;
  __isset = other74.__isset;
  return *this;
}
SmartTransInfo& SmartTransInfo::operator=(SmartTransInfo&& other75) {
  v_tokenDeploy = std::move(other75.v_tokenDeploy);
  v_tokenTransfer = std::move(other75.v_tokenTransfer);
  v_smartDeploy = std::move(other75.v_smartDeploy);
  v_smartExecution = std::move(other75.v_smartExecution);
  v_smartState = std::move(other75.v_smartState);
  __isset = std::move(other75.__isset);
  return *this;
}
void SmartTransInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartTransInfo(";
  out << "v_tokenDeploy="; (__isset.v_tokenDeploy ? (out << to_string(v_tokenDeploy)) : (out << "<null>"));
  out << ", " << "v_tokenTransfer="; (__isset.v_tokenTransfer ? (out << to_string(v_tokenTransfer)) : (out << "<null>"));
  out << ", " << "v_smartDeploy="; (__isset.v_smartDeploy ? (out << to_string(v_smartDeploy)) : (out << "<null>"));
  out << ", " << "v_smartExecution="; (__isset.v_smartExecution ? (out << to_string(v_smartExecution)) : (out << "<null>"));
  out << ", " << "v_smartState="; (__isset.v_smartState ? (out << to_string(v_smartState)) : (out << "<null>"));
  out << ")";
}


Transaction::~Transaction() throw() {
}


void Transaction::__set_id(const TransactionInnerId val) {
  this->id = val;
}

void Transaction::__set_source(const Address& val) {
  this->source = val;
}

void Transaction::__set_target(const Address& val) {
  this->target = val;
}

void Transaction::__set_amount(const Amount& val) {
  this->amount = val;
}

void Transaction::__set_balance(const Amount& val) {
  this->balance = val;
}

void Transaction::__set_currency(const Currency val) {
  this->currency = val;
}

void Transaction::__set_signature(const std::string& val) {
  this->signature = val;
}

void Transaction::__set_smartContract(const SmartContractInvocation& val) {
  this->smartContract = val;
__isset.smartContract = true;
}

void Transaction::__set_fee(const AmountCommission& val) {
  this->fee = val;
}

void Transaction::__set_timeCreation(const Time val) {
  this->timeCreation = val;
}

void Transaction::__set_userFields(const std::string& val) {
  this->userFields = val;
__isset.userFields = true;
}

void Transaction::__set_type(const TransactionType val) {
  this->type = val;
}

void Transaction::__set_smartInfo(const SmartTransInfo& val) {
  this->smartInfo = val;
__isset.smartInfo = true;
}
std::ostream& operator<<(std::ostream& out, const Transaction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Transaction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->source);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->target);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->amount.read(iprot);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->balance.read(iprot);
          this->__isset.balance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->currency);
          this->__isset.currency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->smartContract.read(iprot);
          this->__isset.smartContract = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fee.read(iprot);
          this->__isset.fee = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeCreation);
          this->__isset.timeCreation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->userFields);
          this->__isset.userFields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast76;
          xfer += iprot->readI32(ecast76);
          this->type = (TransactionType)ecast76;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->smartInfo.read(iprot);
          this->__isset.smartInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Transaction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Transaction");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->source);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->amount.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("balance", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->balance.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currency", ::apache::thrift::protocol::T_BYTE, 6);
  xfer += oprot->writeByte(this->currency);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeBinary(this->signature);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.smartContract) {
    xfer += oprot->writeFieldBegin("smartContract", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->smartContract.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("fee", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->fee.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeCreation", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->timeCreation);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.userFields) {
    xfer += oprot->writeFieldBegin("userFields", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeBinary(this->userFields);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.smartInfo) {
    xfer += oprot->writeFieldBegin("smartInfo", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->smartInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Transaction &a, Transaction &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.source, b.source);
  swap(a.target, b.target);
  swap(a.amount, b.amount);
  swap(a.balance, b.balance);
  swap(a.currency, b.currency);
  swap(a.signature, b.signature);
  swap(a.smartContract, b.smartContract);
  swap(a.fee, b.fee);
  swap(a.timeCreation, b.timeCreation);
  swap(a.userFields, b.userFields);
  swap(a.type, b.type);
  swap(a.smartInfo, b.smartInfo);
  swap(a.__isset, b.__isset);
}

Transaction::Transaction(const Transaction& other77) {
  id = other77.id;
  source = other77.source;
  target = other77.target;
  amount = other77.amount;
  balance = other77.balance;
  currency = other77.currency;
  signature = other77.signature;
  smartContract = other77.smartContract;
  fee = other77.fee;
  timeCreation = other77.timeCreation;
  userFields = other77.userFields;
  type = other77.type;
  smartInfo = other77.smartInfo;
  __isset = other77.__isset;
}
Transaction::Transaction( Transaction&& other78) {
  id = std::move(other78.id);
  source = std::move(other78.source);
  target = std::move(other78.target);
  amount = std::move(other78.amount);
  balance = std::move(other78.balance);
  currency = std::move(other78.currency);
  signature = std::move(other78.signature);
  smartContract = std::move(other78.smartContract);
  fee = std::move(other78.fee);
  timeCreation = std::move(other78.timeCreation);
  userFields = std::move(other78.userFields);
  type = std::move(other78.type);
  smartInfo = std::move(other78.smartInfo);
  __isset = std::move(other78.__isset);
}
Transaction& Transaction::operator=(const Transaction& other79) {
  id = other79.id;
  source = other79.source;
  target = other79.target;
  amount = other79.amount;
  balance = other79.balance;
  currency = other79.currency;
  signature = other79.signature;
  smartContract = other79.smartContract;
  fee = other79.fee;
  timeCreation = other79.timeCreation;
  userFields = other79.userFields;
  type = other79.type;
  smartInfo = other79.smartInfo;
  __isset = other79.__isset;
  return *this;
}
Transaction& Transaction::operator=(Transaction&& other80) {
  id = std::move(other80.id);
  source = std::move(other80.source);
  target = std::move(other80.target);
  amount = std::move(other80.amount);
  balance = std::move(other80.balance);
  currency = std::move(other80.currency);
  signature = std::move(other80.signature);
  smartContract = std::move(other80.smartContract);
  fee = std::move(other80.fee);
  timeCreation = std::move(other80.timeCreation);
  userFields = std::move(other80.userFields);
  type = std::move(other80.type);
  smartInfo = std::move(other80.smartInfo);
  __isset = std::move(other80.__isset);
  return *this;
}
void Transaction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Transaction(";
  out << "id=" << to_string(id);
  out << ", " << "source=" << to_string(source);
  out << ", " << "target=" << to_string(target);
  out << ", " << "amount=" << to_string(amount);
  out << ", " << "balance=" << to_string(balance);
  out << ", " << "currency=" << to_string(currency);
  out << ", " << "signature=" << to_string(signature);
  out << ", " << "smartContract="; (__isset.smartContract ? (out << to_string(smartContract)) : (out << "<null>"));
  out << ", " << "fee=" << to_string(fee);
  out << ", " << "timeCreation=" << to_string(timeCreation);
  out << ", " << "userFields="; (__isset.userFields ? (out << to_string(userFields)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "smartInfo="; (__isset.smartInfo ? (out << to_string(smartInfo)) : (out << "<null>"));
  out << ")";
}


SealedTransaction::~SealedTransaction() throw() {
}


void SealedTransaction::__set_id(const TransactionId& val) {
  this->id = val;
}

void SealedTransaction::__set_trxn(const Transaction& val) {
  this->trxn = val;
}
std::ostream& operator<<(std::ostream& out, const SealedTransaction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SealedTransaction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id.read(iprot);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->trxn.read(iprot);
          this->__isset.trxn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SealedTransaction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SealedTransaction");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("trxn", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->trxn.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SealedTransaction &a, SealedTransaction &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.trxn, b.trxn);
  swap(a.__isset, b.__isset);
}

SealedTransaction::SealedTransaction(const SealedTransaction& other81) {
  id = other81.id;
  trxn = other81.trxn;
  __isset = other81.__isset;
}
SealedTransaction::SealedTransaction( SealedTransaction&& other82) {
  id = std::move(other82.id);
  trxn = std::move(other82.trxn);
  __isset = std::move(other82.__isset);
}
SealedTransaction& SealedTransaction::operator=(const SealedTransaction& other83) {
  id = other83.id;
  trxn = other83.trxn;
  __isset = other83.__isset;
  return *this;
}
SealedTransaction& SealedTransaction::operator=(SealedTransaction&& other84) {
  id = std::move(other84.id);
  trxn = std::move(other84.trxn);
  __isset = std::move(other84.__isset);
  return *this;
}
void SealedTransaction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SealedTransaction(";
  out << "id=" << to_string(id);
  out << ", " << "trxn=" << to_string(trxn);
  out << ")";
}


Pool::~Pool() throw() {
}


void Pool::__set_hash(const PoolHash& val) {
  this->hash = val;
}

void Pool::__set_prevHash(const PoolHash& val) {
  this->prevHash = val;
}

void Pool::__set_time(const Time val) {
  this->time = val;
}

void Pool::__set_transactionsCount(const int32_t val) {
  this->transactionsCount = val;
}

void Pool::__set_poolNumber(const PoolNumber val) {
  this->poolNumber = val;
}

void Pool::__set_writer(const Address& val) {
  this->writer = val;
}

void Pool::__set_totalFee(const Amount& val) {
  this->totalFee = val;
}
std::ostream& operator<<(std::ostream& out, const Pool& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Pool::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->hash);
          this->__isset.hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->prevHash);
          this->__isset.prevHash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->transactionsCount);
          this->__isset.transactionsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->poolNumber);
          this->__isset.poolNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->writer);
          this->__isset.writer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->totalFee.read(iprot);
          this->__isset.totalFee = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Pool::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Pool");

  xfer += oprot->writeFieldBegin("hash", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prevHash", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->prevHash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactionsCount", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->transactionsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poolNumber", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->poolNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writer", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->writer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalFee", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->totalFee.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Pool &a, Pool &b) {
  using ::std::swap;
  swap(a.hash, b.hash);
  swap(a.prevHash, b.prevHash);
  swap(a.time, b.time);
  swap(a.transactionsCount, b.transactionsCount);
  swap(a.poolNumber, b.poolNumber);
  swap(a.writer, b.writer);
  swap(a.totalFee, b.totalFee);
  swap(a.__isset, b.__isset);
}

Pool::Pool(const Pool& other85) {
  hash = other85.hash;
  prevHash = other85.prevHash;
  time = other85.time;
  transactionsCount = other85.transactionsCount;
  poolNumber = other85.poolNumber;
  writer = other85.writer;
  totalFee = other85.totalFee;
  __isset = other85.__isset;
}
Pool::Pool( Pool&& other86) {
  hash = std::move(other86.hash);
  prevHash = std::move(other86.prevHash);
  time = std::move(other86.time);
  transactionsCount = std::move(other86.transactionsCount);
  poolNumber = std::move(other86.poolNumber);
  writer = std::move(other86.writer);
  totalFee = std::move(other86.totalFee);
  __isset = std::move(other86.__isset);
}
Pool& Pool::operator=(const Pool& other87) {
  hash = other87.hash;
  prevHash = other87.prevHash;
  time = other87.time;
  transactionsCount = other87.transactionsCount;
  poolNumber = other87.poolNumber;
  writer = other87.writer;
  totalFee = other87.totalFee;
  __isset = other87.__isset;
  return *this;
}
Pool& Pool::operator=(Pool&& other88) {
  hash = std::move(other88.hash);
  prevHash = std::move(other88.prevHash);
  time = std::move(other88.time);
  transactionsCount = std::move(other88.transactionsCount);
  poolNumber = std::move(other88.poolNumber);
  writer = std::move(other88.writer);
  totalFee = std::move(other88.totalFee);
  __isset = std::move(other88.__isset);
  return *this;
}
void Pool::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Pool(";
  out << "hash=" << to_string(hash);
  out << ", " << "prevHash=" << to_string(prevHash);
  out << ", " << "time=" << to_string(time);
  out << ", " << "transactionsCount=" << to_string(transactionsCount);
  out << ", " << "poolNumber=" << to_string(poolNumber);
  out << ", " << "writer=" << to_string(writer);
  out << ", " << "totalFee=" << to_string(totalFee);
  out << ")";
}


WalletData::~WalletData() throw() {
}


void WalletData::__set_walletId(const WalletId val) {
  this->walletId = val;
}

void WalletData::__set_balance(const Amount& val) {
  this->balance = val;
}

void WalletData::__set_lastTransactionId(const TransactionInnerId val) {
  this->lastTransactionId = val;
}
std::ostream& operator<<(std::ostream& out, const WalletData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WalletData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->walletId);
          this->__isset.walletId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->balance.read(iprot);
          this->__isset.balance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastTransactionId);
          this->__isset.lastTransactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WalletData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WalletData");

  xfer += oprot->writeFieldBegin("walletId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->walletId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("balance", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->balance.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastTransactionId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->lastTransactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WalletData &a, WalletData &b) {
  using ::std::swap;
  swap(a.walletId, b.walletId);
  swap(a.balance, b.balance);
  swap(a.lastTransactionId, b.lastTransactionId);
  swap(a.__isset, b.__isset);
}

WalletData::WalletData(const WalletData& other89) {
  walletId = other89.walletId;
  balance = other89.balance;
  lastTransactionId = other89.lastTransactionId;
  __isset = other89.__isset;
}
WalletData::WalletData( WalletData&& other90) {
  walletId = std::move(other90.walletId);
  balance = std::move(other90.balance);
  lastTransactionId = std::move(other90.lastTransactionId);
  __isset = std::move(other90.__isset);
}
WalletData& WalletData::operator=(const WalletData& other91) {
  walletId = other91.walletId;
  balance = other91.balance;
  lastTransactionId = other91.lastTransactionId;
  __isset = other91.__isset;
  return *this;
}
WalletData& WalletData::operator=(WalletData&& other92) {
  walletId = std::move(other92.walletId);
  balance = std::move(other92.balance);
  lastTransactionId = std::move(other92.lastTransactionId);
  __isset = std::move(other92.__isset);
  return *this;
}
void WalletData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WalletData(";
  out << "walletId=" << to_string(walletId);
  out << ", " << "balance=" << to_string(balance);
  out << ", " << "lastTransactionId=" << to_string(lastTransactionId);
  out << ")";
}


PeriodStats::~PeriodStats() throw() {
}


void PeriodStats::__set_periodDuration(const Time val) {
  this->periodDuration = val;
}

void PeriodStats::__set_poolsCount(const Count val) {
  this->poolsCount = val;
}

void PeriodStats::__set_transactionsCount(const Count val) {
  this->transactionsCount = val;
}

void PeriodStats::__set_balancePerCurrency(const Total& val) {
  this->balancePerCurrency = val;
}

void PeriodStats::__set_smartContractsCount(const Count val) {
  this->smartContractsCount = val;
}

void PeriodStats::__set_transactionsSmartCount(const Count val) {
  this->transactionsSmartCount = val;
}
std::ostream& operator<<(std::ostream& out, const PeriodStats& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PeriodStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->periodDuration);
          this->__isset.periodDuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->poolsCount);
          this->__isset.poolsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->transactionsCount);
          this->__isset.transactionsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->balancePerCurrency.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _ktype94;
            ::apache::thrift::protocol::TType _vtype95;
            xfer += iprot->readMapBegin(_ktype94, _vtype95, _size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              Currency _key98;
              xfer += iprot->readByte(_key98);
              CumulativeAmount& _val99 = this->balancePerCurrency[_key98];
              xfer += _val99.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.balancePerCurrency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->smartContractsCount);
          this->__isset.smartContractsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->transactionsSmartCount);
          this->__isset.transactionsSmartCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PeriodStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PeriodStats");

  xfer += oprot->writeFieldBegin("periodDuration", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->periodDuration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poolsCount", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->poolsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactionsCount", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->transactionsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("balancePerCurrency", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->balancePerCurrency.size()));
    std::map<Currency, CumulativeAmount> ::const_iterator _iter100;
    for (_iter100 = this->balancePerCurrency.begin(); _iter100 != this->balancePerCurrency.end(); ++_iter100)
    {
      xfer += oprot->writeByte(_iter100->first);
      xfer += _iter100->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("smartContractsCount", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->smartContractsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactionsSmartCount", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->transactionsSmartCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PeriodStats &a, PeriodStats &b) {
  using ::std::swap;
  swap(a.periodDuration, b.periodDuration);
  swap(a.poolsCount, b.poolsCount);
  swap(a.transactionsCount, b.transactionsCount);
  swap(a.balancePerCurrency, b.balancePerCurrency);
  swap(a.smartContractsCount, b.smartContractsCount);
  swap(a.transactionsSmartCount, b.transactionsSmartCount);
  swap(a.__isset, b.__isset);
}

PeriodStats::PeriodStats(const PeriodStats& other101) {
  periodDuration = other101.periodDuration;
  poolsCount = other101.poolsCount;
  transactionsCount = other101.transactionsCount;
  balancePerCurrency = other101.balancePerCurrency;
  smartContractsCount = other101.smartContractsCount;
  transactionsSmartCount = other101.transactionsSmartCount;
  __isset = other101.__isset;
}
PeriodStats::PeriodStats( PeriodStats&& other102) {
  periodDuration = std::move(other102.periodDuration);
  poolsCount = std::move(other102.poolsCount);
  transactionsCount = std::move(other102.transactionsCount);
  balancePerCurrency = std::move(other102.balancePerCurrency);
  smartContractsCount = std::move(other102.smartContractsCount);
  transactionsSmartCount = std::move(other102.transactionsSmartCount);
  __isset = std::move(other102.__isset);
}
PeriodStats& PeriodStats::operator=(const PeriodStats& other103) {
  periodDuration = other103.periodDuration;
  poolsCount = other103.poolsCount;
  transactionsCount = other103.transactionsCount;
  balancePerCurrency = other103.balancePerCurrency;
  smartContractsCount = other103.smartContractsCount;
  transactionsSmartCount = other103.transactionsSmartCount;
  __isset = other103.__isset;
  return *this;
}
PeriodStats& PeriodStats::operator=(PeriodStats&& other104) {
  periodDuration = std::move(other104.periodDuration);
  poolsCount = std::move(other104.poolsCount);
  transactionsCount = std::move(other104.transactionsCount);
  balancePerCurrency = std::move(other104.balancePerCurrency);
  smartContractsCount = std::move(other104.smartContractsCount);
  transactionsSmartCount = std::move(other104.transactionsSmartCount);
  __isset = std::move(other104.__isset);
  return *this;
}
void PeriodStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PeriodStats(";
  out << "periodDuration=" << to_string(periodDuration);
  out << ", " << "poolsCount=" << to_string(poolsCount);
  out << ", " << "transactionsCount=" << to_string(transactionsCount);
  out << ", " << "balancePerCurrency=" << to_string(balancePerCurrency);
  out << ", " << "smartContractsCount=" << to_string(smartContractsCount);
  out << ", " << "transactionsSmartCount=" << to_string(transactionsSmartCount);
  out << ")";
}


WalletDataGetResult::~WalletDataGetResult() throw() {
}


void WalletDataGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void WalletDataGetResult::__set_walletData(const WalletData& val) {
  this->walletData = val;
}
std::ostream& operator<<(std::ostream& out, const WalletDataGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WalletDataGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->walletData.read(iprot);
          this->__isset.walletData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WalletDataGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WalletDataGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("walletData", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->walletData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WalletDataGetResult &a, WalletDataGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.walletData, b.walletData);
  swap(a.__isset, b.__isset);
}

WalletDataGetResult::WalletDataGetResult(const WalletDataGetResult& other105) {
  status = other105.status;
  walletData = other105.walletData;
  __isset = other105.__isset;
}
WalletDataGetResult::WalletDataGetResult( WalletDataGetResult&& other106) {
  status = std::move(other106.status);
  walletData = std::move(other106.walletData);
  __isset = std::move(other106.__isset);
}
WalletDataGetResult& WalletDataGetResult::operator=(const WalletDataGetResult& other107) {
  status = other107.status;
  walletData = other107.walletData;
  __isset = other107.__isset;
  return *this;
}
WalletDataGetResult& WalletDataGetResult::operator=(WalletDataGetResult&& other108) {
  status = std::move(other108.status);
  walletData = std::move(other108.walletData);
  __isset = std::move(other108.__isset);
  return *this;
}
void WalletDataGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WalletDataGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "walletData=" << to_string(walletData);
  out << ")";
}


WalletIdGetResult::~WalletIdGetResult() throw() {
}


void WalletIdGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void WalletIdGetResult::__set_walletId(const WalletId val) {
  this->walletId = val;
}
std::ostream& operator<<(std::ostream& out, const WalletIdGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WalletIdGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->walletId);
          this->__isset.walletId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WalletIdGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WalletIdGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("walletId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->walletId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WalletIdGetResult &a, WalletIdGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.walletId, b.walletId);
  swap(a.__isset, b.__isset);
}

WalletIdGetResult::WalletIdGetResult(const WalletIdGetResult& other109) {
  status = other109.status;
  walletId = other109.walletId;
  __isset = other109.__isset;
}
WalletIdGetResult::WalletIdGetResult( WalletIdGetResult&& other110) {
  status = std::move(other110.status);
  walletId = std::move(other110.walletId);
  __isset = std::move(other110.__isset);
}
WalletIdGetResult& WalletIdGetResult::operator=(const WalletIdGetResult& other111) {
  status = other111.status;
  walletId = other111.walletId;
  __isset = other111.__isset;
  return *this;
}
WalletIdGetResult& WalletIdGetResult::operator=(WalletIdGetResult&& other112) {
  status = std::move(other112.status);
  walletId = std::move(other112.walletId);
  __isset = std::move(other112.__isset);
  return *this;
}
void WalletIdGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WalletIdGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "walletId=" << to_string(walletId);
  out << ")";
}


WalletTransactionsCountGetResult::~WalletTransactionsCountGetResult() throw() {
}


void WalletTransactionsCountGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void WalletTransactionsCountGetResult::__set_lastTransactionInnerId(const TransactionInnerId val) {
  this->lastTransactionInnerId = val;
}
std::ostream& operator<<(std::ostream& out, const WalletTransactionsCountGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WalletTransactionsCountGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastTransactionInnerId);
          this->__isset.lastTransactionInnerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WalletTransactionsCountGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WalletTransactionsCountGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastTransactionInnerId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->lastTransactionInnerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WalletTransactionsCountGetResult &a, WalletTransactionsCountGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.lastTransactionInnerId, b.lastTransactionInnerId);
  swap(a.__isset, b.__isset);
}

WalletTransactionsCountGetResult::WalletTransactionsCountGetResult(const WalletTransactionsCountGetResult& other113) {
  status = other113.status;
  lastTransactionInnerId = other113.lastTransactionInnerId;
  __isset = other113.__isset;
}
WalletTransactionsCountGetResult::WalletTransactionsCountGetResult( WalletTransactionsCountGetResult&& other114) {
  status = std::move(other114.status);
  lastTransactionInnerId = std::move(other114.lastTransactionInnerId);
  __isset = std::move(other114.__isset);
}
WalletTransactionsCountGetResult& WalletTransactionsCountGetResult::operator=(const WalletTransactionsCountGetResult& other115) {
  status = other115.status;
  lastTransactionInnerId = other115.lastTransactionInnerId;
  __isset = other115.__isset;
  return *this;
}
WalletTransactionsCountGetResult& WalletTransactionsCountGetResult::operator=(WalletTransactionsCountGetResult&& other116) {
  status = std::move(other116.status);
  lastTransactionInnerId = std::move(other116.lastTransactionInnerId);
  __isset = std::move(other116.__isset);
  return *this;
}
void WalletTransactionsCountGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WalletTransactionsCountGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "lastTransactionInnerId=" << to_string(lastTransactionInnerId);
  out << ")";
}


WalletBalanceGetResult::~WalletBalanceGetResult() throw() {
}


void WalletBalanceGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void WalletBalanceGetResult::__set_balance(const Amount& val) {
  this->balance = val;
}
std::ostream& operator<<(std::ostream& out, const WalletBalanceGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WalletBalanceGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->balance.read(iprot);
          this->__isset.balance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WalletBalanceGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WalletBalanceGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("balance", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->balance.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WalletBalanceGetResult &a, WalletBalanceGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.balance, b.balance);
  swap(a.__isset, b.__isset);
}

WalletBalanceGetResult::WalletBalanceGetResult(const WalletBalanceGetResult& other117) {
  status = other117.status;
  balance = other117.balance;
  __isset = other117.__isset;
}
WalletBalanceGetResult::WalletBalanceGetResult( WalletBalanceGetResult&& other118) {
  status = std::move(other118.status);
  balance = std::move(other118.balance);
  __isset = std::move(other118.__isset);
}
WalletBalanceGetResult& WalletBalanceGetResult::operator=(const WalletBalanceGetResult& other119) {
  status = other119.status;
  balance = other119.balance;
  __isset = other119.__isset;
  return *this;
}
WalletBalanceGetResult& WalletBalanceGetResult::operator=(WalletBalanceGetResult&& other120) {
  status = std::move(other120.status);
  balance = std::move(other120.balance);
  __isset = std::move(other120.__isset);
  return *this;
}
void WalletBalanceGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WalletBalanceGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "balance=" << to_string(balance);
  out << ")";
}


TransactionGetResult::~TransactionGetResult() throw() {
}


void TransactionGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void TransactionGetResult::__set_found(const bool val) {
  this->found = val;
}

void TransactionGetResult::__set_state(const TransactionState val) {
  this->state = val;
}

void TransactionGetResult::__set_roundNum(const int32_t val) {
  this->roundNum = val;
}

void TransactionGetResult::__set_transaction(const SealedTransaction& val) {
  this->transaction = val;
}
std::ostream& operator<<(std::ostream& out, const TransactionGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TransactionGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->found);
          this->__isset.found = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast121;
          xfer += iprot->readI32(ecast121);
          this->state = (TransactionState)ecast121;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->roundNum);
          this->__isset.roundNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transaction.read(iprot);
          this->__isset.transaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TransactionGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TransactionGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("found", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->found);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roundNum", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->roundNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transaction", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->transaction.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransactionGetResult &a, TransactionGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.found, b.found);
  swap(a.state, b.state);
  swap(a.roundNum, b.roundNum);
  swap(a.transaction, b.transaction);
  swap(a.__isset, b.__isset);
}

TransactionGetResult::TransactionGetResult(const TransactionGetResult& other122) {
  status = other122.status;
  found = other122.found;
  state = other122.state;
  roundNum = other122.roundNum;
  transaction = other122.transaction;
  __isset = other122.__isset;
}
TransactionGetResult::TransactionGetResult( TransactionGetResult&& other123) {
  status = std::move(other123.status);
  found = std::move(other123.found);
  state = std::move(other123.state);
  roundNum = std::move(other123.roundNum);
  transaction = std::move(other123.transaction);
  __isset = std::move(other123.__isset);
}
TransactionGetResult& TransactionGetResult::operator=(const TransactionGetResult& other124) {
  status = other124.status;
  found = other124.found;
  state = other124.state;
  roundNum = other124.roundNum;
  transaction = other124.transaction;
  __isset = other124.__isset;
  return *this;
}
TransactionGetResult& TransactionGetResult::operator=(TransactionGetResult&& other125) {
  status = std::move(other125.status);
  found = std::move(other125.found);
  state = std::move(other125.state);
  roundNum = std::move(other125.roundNum);
  transaction = std::move(other125.transaction);
  __isset = std::move(other125.__isset);
  return *this;
}
void TransactionGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TransactionGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "found=" << to_string(found);
  out << ", " << "state=" << to_string(state);
  out << ", " << "roundNum=" << to_string(roundNum);
  out << ", " << "transaction=" << to_string(transaction);
  out << ")";
}


TransactionsGetResult::~TransactionsGetResult() throw() {
}


void TransactionsGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void TransactionsGetResult::__set_result(const bool val) {
  this->result = val;
}

void TransactionsGetResult::__set_total_trxns_count(const int32_t val) {
  this->total_trxns_count = val;
}

void TransactionsGetResult::__set_transactions(const std::vector<SealedTransaction> & val) {
  this->transactions = val;
}
std::ostream& operator<<(std::ostream& out, const TransactionsGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TransactionsGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_trxns_count);
          this->__isset.total_trxns_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->transactions.clear();
            uint32_t _size126;
            ::apache::thrift::protocol::TType _etype129;
            xfer += iprot->readListBegin(_etype129, _size126);
            this->transactions.resize(_size126);
            uint32_t _i130;
            for (_i130 = 0; _i130 < _size126; ++_i130)
            {
              xfer += this->transactions[_i130].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.transactions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TransactionsGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TransactionsGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_trxns_count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->total_trxns_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactions", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->transactions.size()));
    std::vector<SealedTransaction> ::const_iterator _iter131;
    for (_iter131 = this->transactions.begin(); _iter131 != this->transactions.end(); ++_iter131)
    {
      xfer += (*_iter131).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransactionsGetResult &a, TransactionsGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.result, b.result);
  swap(a.total_trxns_count, b.total_trxns_count);
  swap(a.transactions, b.transactions);
  swap(a.__isset, b.__isset);
}

TransactionsGetResult::TransactionsGetResult(const TransactionsGetResult& other132) {
  status = other132.status;
  result = other132.result;
  total_trxns_count = other132.total_trxns_count;
  transactions = other132.transactions;
  __isset = other132.__isset;
}
TransactionsGetResult::TransactionsGetResult( TransactionsGetResult&& other133) {
  status = std::move(other133.status);
  result = std::move(other133.result);
  total_trxns_count = std::move(other133.total_trxns_count);
  transactions = std::move(other133.transactions);
  __isset = std::move(other133.__isset);
}
TransactionsGetResult& TransactionsGetResult::operator=(const TransactionsGetResult& other134) {
  status = other134.status;
  result = other134.result;
  total_trxns_count = other134.total_trxns_count;
  transactions = other134.transactions;
  __isset = other134.__isset;
  return *this;
}
TransactionsGetResult& TransactionsGetResult::operator=(TransactionsGetResult&& other135) {
  status = std::move(other135.status);
  result = std::move(other135.result);
  total_trxns_count = std::move(other135.total_trxns_count);
  transactions = std::move(other135.transactions);
  __isset = std::move(other135.__isset);
  return *this;
}
void TransactionsGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TransactionsGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "result=" << to_string(result);
  out << ", " << "total_trxns_count=" << to_string(total_trxns_count);
  out << ", " << "transactions=" << to_string(transactions);
  out << ")";
}


TransactionFlowResult::~TransactionFlowResult() throw() {
}


void TransactionFlowResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void TransactionFlowResult::__set_smart_contract_result(const  ::general::Variant& val) {
  this->smart_contract_result = val;
__isset.smart_contract_result = true;
}

void TransactionFlowResult::__set_roundNum(const int32_t val) {
  this->roundNum = val;
}
std::ostream& operator<<(std::ostream& out, const TransactionFlowResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TransactionFlowResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->smart_contract_result.read(iprot);
          this->__isset.smart_contract_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->roundNum);
          this->__isset.roundNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TransactionFlowResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TransactionFlowResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.smart_contract_result) {
    xfer += oprot->writeFieldBegin("smart_contract_result", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->smart_contract_result.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("roundNum", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->roundNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransactionFlowResult &a, TransactionFlowResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.smart_contract_result, b.smart_contract_result);
  swap(a.roundNum, b.roundNum);
  swap(a.__isset, b.__isset);
}

TransactionFlowResult::TransactionFlowResult(const TransactionFlowResult& other136) {
  status = other136.status;
  smart_contract_result = other136.smart_contract_result;
  roundNum = other136.roundNum;
  __isset = other136.__isset;
}
TransactionFlowResult::TransactionFlowResult( TransactionFlowResult&& other137) {
  status = std::move(other137.status);
  smart_contract_result = std::move(other137.smart_contract_result);
  roundNum = std::move(other137.roundNum);
  __isset = std::move(other137.__isset);
}
TransactionFlowResult& TransactionFlowResult::operator=(const TransactionFlowResult& other138) {
  status = other138.status;
  smart_contract_result = other138.smart_contract_result;
  roundNum = other138.roundNum;
  __isset = other138.__isset;
  return *this;
}
TransactionFlowResult& TransactionFlowResult::operator=(TransactionFlowResult&& other139) {
  status = std::move(other139.status);
  smart_contract_result = std::move(other139.smart_contract_result);
  roundNum = std::move(other139.roundNum);
  __isset = std::move(other139.__isset);
  return *this;
}
void TransactionFlowResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TransactionFlowResult(";
  out << "status=" << to_string(status);
  out << ", " << "smart_contract_result="; (__isset.smart_contract_result ? (out << to_string(smart_contract_result)) : (out << "<null>"));
  out << ", " << "roundNum=" << to_string(roundNum);
  out << ")";
}


PoolListGetResult::~PoolListGetResult() throw() {
}


void PoolListGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void PoolListGetResult::__set_result(const bool val) {
  this->result = val;
}

void PoolListGetResult::__set_count(const int32_t val) {
  this->count = val;
}

void PoolListGetResult::__set_pools(const std::vector<Pool> & val) {
  this->pools = val;
}
std::ostream& operator<<(std::ostream& out, const PoolListGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PoolListGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pools.clear();
            uint32_t _size140;
            ::apache::thrift::protocol::TType _etype143;
            xfer += iprot->readListBegin(_etype143, _size140);
            this->pools.resize(_size140);
            uint32_t _i144;
            for (_i144 = 0; _i144 < _size140; ++_i144)
            {
              xfer += this->pools[_i144].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.pools = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PoolListGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PoolListGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pools", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pools.size()));
    std::vector<Pool> ::const_iterator _iter145;
    for (_iter145 = this->pools.begin(); _iter145 != this->pools.end(); ++_iter145)
    {
      xfer += (*_iter145).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PoolListGetResult &a, PoolListGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.result, b.result);
  swap(a.count, b.count);
  swap(a.pools, b.pools);
  swap(a.__isset, b.__isset);
}

PoolListGetResult::PoolListGetResult(const PoolListGetResult& other146) {
  status = other146.status;
  result = other146.result;
  count = other146.count;
  pools = other146.pools;
  __isset = other146.__isset;
}
PoolListGetResult::PoolListGetResult( PoolListGetResult&& other147) {
  status = std::move(other147.status);
  result = std::move(other147.result);
  count = std::move(other147.count);
  pools = std::move(other147.pools);
  __isset = std::move(other147.__isset);
}
PoolListGetResult& PoolListGetResult::operator=(const PoolListGetResult& other148) {
  status = other148.status;
  result = other148.result;
  count = other148.count;
  pools = other148.pools;
  __isset = other148.__isset;
  return *this;
}
PoolListGetResult& PoolListGetResult::operator=(PoolListGetResult&& other149) {
  status = std::move(other149.status);
  result = std::move(other149.result);
  count = std::move(other149.count);
  pools = std::move(other149.pools);
  __isset = std::move(other149.__isset);
  return *this;
}
void PoolListGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PoolListGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "result=" << to_string(result);
  out << ", " << "count=" << to_string(count);
  out << ", " << "pools=" << to_string(pools);
  out << ")";
}


PoolInfoGetResult::~PoolInfoGetResult() throw() {
}


void PoolInfoGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void PoolInfoGetResult::__set_isFound(const bool val) {
  this->isFound = val;
}

void PoolInfoGetResult::__set_pool(const Pool& val) {
  this->pool = val;
}
std::ostream& operator<<(std::ostream& out, const PoolInfoGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PoolInfoGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isFound);
          this->__isset.isFound = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pool.read(iprot);
          this->__isset.pool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PoolInfoGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PoolInfoGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isFound", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isFound);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pool", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->pool.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PoolInfoGetResult &a, PoolInfoGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.isFound, b.isFound);
  swap(a.pool, b.pool);
  swap(a.__isset, b.__isset);
}

PoolInfoGetResult::PoolInfoGetResult(const PoolInfoGetResult& other150) {
  status = other150.status;
  isFound = other150.isFound;
  pool = other150.pool;
  __isset = other150.__isset;
}
PoolInfoGetResult::PoolInfoGetResult( PoolInfoGetResult&& other151) {
  status = std::move(other151.status);
  isFound = std::move(other151.isFound);
  pool = std::move(other151.pool);
  __isset = std::move(other151.__isset);
}
PoolInfoGetResult& PoolInfoGetResult::operator=(const PoolInfoGetResult& other152) {
  status = other152.status;
  isFound = other152.isFound;
  pool = other152.pool;
  __isset = other152.__isset;
  return *this;
}
PoolInfoGetResult& PoolInfoGetResult::operator=(PoolInfoGetResult&& other153) {
  status = std::move(other153.status);
  isFound = std::move(other153.isFound);
  pool = std::move(other153.pool);
  __isset = std::move(other153.__isset);
  return *this;
}
void PoolInfoGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PoolInfoGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "isFound=" << to_string(isFound);
  out << ", " << "pool=" << to_string(pool);
  out << ")";
}


PoolTransactionsGetResult::~PoolTransactionsGetResult() throw() {
}


void PoolTransactionsGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void PoolTransactionsGetResult::__set_transactions(const std::vector<SealedTransaction> & val) {
  this->transactions = val;
}
std::ostream& operator<<(std::ostream& out, const PoolTransactionsGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PoolTransactionsGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->transactions.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readListBegin(_etype157, _size154);
            this->transactions.resize(_size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              xfer += this->transactions[_i158].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.transactions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PoolTransactionsGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PoolTransactionsGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->transactions.size()));
    std::vector<SealedTransaction> ::const_iterator _iter159;
    for (_iter159 = this->transactions.begin(); _iter159 != this->transactions.end(); ++_iter159)
    {
      xfer += (*_iter159).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PoolTransactionsGetResult &a, PoolTransactionsGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.transactions, b.transactions);
  swap(a.__isset, b.__isset);
}

PoolTransactionsGetResult::PoolTransactionsGetResult(const PoolTransactionsGetResult& other160) {
  status = other160.status;
  transactions = other160.transactions;
  __isset = other160.__isset;
}
PoolTransactionsGetResult::PoolTransactionsGetResult( PoolTransactionsGetResult&& other161) {
  status = std::move(other161.status);
  transactions = std::move(other161.transactions);
  __isset = std::move(other161.__isset);
}
PoolTransactionsGetResult& PoolTransactionsGetResult::operator=(const PoolTransactionsGetResult& other162) {
  status = other162.status;
  transactions = other162.transactions;
  __isset = other162.__isset;
  return *this;
}
PoolTransactionsGetResult& PoolTransactionsGetResult::operator=(PoolTransactionsGetResult&& other163) {
  status = std::move(other163.status);
  transactions = std::move(other163.transactions);
  __isset = std::move(other163.__isset);
  return *this;
}
void PoolTransactionsGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PoolTransactionsGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "transactions=" << to_string(transactions);
  out << ")";
}


StatsGetResult::~StatsGetResult() throw() {
}


void StatsGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void StatsGetResult::__set_stats(const StatsPerPeriod& val) {
  this->stats = val;
}
std::ostream& operator<<(std::ostream& out, const StatsGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StatsGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stats.clear();
            uint32_t _size164;
            ::apache::thrift::protocol::TType _etype167;
            xfer += iprot->readListBegin(_etype167, _size164);
            this->stats.resize(_size164);
            uint32_t _i168;
            for (_i168 = 0; _i168 < _size164; ++_i168)
            {
              xfer += this->stats[_i168].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StatsGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StatsGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stats", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->stats.size()));
    std::vector<PeriodStats> ::const_iterator _iter169;
    for (_iter169 = this->stats.begin(); _iter169 != this->stats.end(); ++_iter169)
    {
      xfer += (*_iter169).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StatsGetResult &a, StatsGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.stats, b.stats);
  swap(a.__isset, b.__isset);
}

StatsGetResult::StatsGetResult(const StatsGetResult& other170) {
  status = other170.status;
  stats = other170.stats;
  __isset = other170.__isset;
}
StatsGetResult::StatsGetResult( StatsGetResult&& other171) {
  status = std::move(other171.status);
  stats = std::move(other171.stats);
  __isset = std::move(other171.__isset);
}
StatsGetResult& StatsGetResult::operator=(const StatsGetResult& other172) {
  status = other172.status;
  stats = other172.stats;
  __isset = other172.__isset;
  return *this;
}
StatsGetResult& StatsGetResult::operator=(StatsGetResult&& other173) {
  status = std::move(other173.status);
  stats = std::move(other173.stats);
  __isset = std::move(other173.__isset);
  return *this;
}
void StatsGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StatsGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "stats=" << to_string(stats);
  out << ")";
}


SmartContractGetResult::~SmartContractGetResult() throw() {
}


void SmartContractGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void SmartContractGetResult::__set_smartContract(const SmartContract& val) {
  this->smartContract = val;
}
std::ostream& operator<<(std::ostream& out, const SmartContractGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContractGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->smartContract.read(iprot);
          this->__isset.smartContract = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartContractGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContractGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("smartContract", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->smartContract.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContractGetResult &a, SmartContractGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.smartContract, b.smartContract);
  swap(a.__isset, b.__isset);
}

SmartContractGetResult::SmartContractGetResult(const SmartContractGetResult& other174) {
  status = other174.status;
  smartContract = other174.smartContract;
  __isset = other174.__isset;
}
SmartContractGetResult::SmartContractGetResult( SmartContractGetResult&& other175) {
  status = std::move(other175.status);
  smartContract = std::move(other175.smartContract);
  __isset = std::move(other175.__isset);
}
SmartContractGetResult& SmartContractGetResult::operator=(const SmartContractGetResult& other176) {
  status = other176.status;
  smartContract = other176.smartContract;
  __isset = other176.__isset;
  return *this;
}
SmartContractGetResult& SmartContractGetResult::operator=(SmartContractGetResult&& other177) {
  status = std::move(other177.status);
  smartContract = std::move(other177.smartContract);
  __isset = std::move(other177.__isset);
  return *this;
}
void SmartContractGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContractGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "smartContract=" << to_string(smartContract);
  out << ")";
}


SmartContractAddressesListGetResult::~SmartContractAddressesListGetResult() throw() {
}


void SmartContractAddressesListGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void SmartContractAddressesListGetResult::__set_addressesList(const std::vector<Address> & val) {
  this->addressesList = val;
}
std::ostream& operator<<(std::ostream& out, const SmartContractAddressesListGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContractAddressesListGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->addressesList.clear();
            uint32_t _size178;
            ::apache::thrift::protocol::TType _etype181;
            xfer += iprot->readListBegin(_etype181, _size178);
            this->addressesList.resize(_size178);
            uint32_t _i182;
            for (_i182 = 0; _i182 < _size178; ++_i182)
            {
              xfer += iprot->readBinary(this->addressesList[_i182]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.addressesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartContractAddressesListGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContractAddressesListGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addressesList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->addressesList.size()));
    std::vector<Address> ::const_iterator _iter183;
    for (_iter183 = this->addressesList.begin(); _iter183 != this->addressesList.end(); ++_iter183)
    {
      xfer += oprot->writeBinary((*_iter183));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContractAddressesListGetResult &a, SmartContractAddressesListGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.addressesList, b.addressesList);
  swap(a.__isset, b.__isset);
}

SmartContractAddressesListGetResult::SmartContractAddressesListGetResult(const SmartContractAddressesListGetResult& other184) {
  status = other184.status;
  addressesList = other184.addressesList;
  __isset = other184.__isset;
}
SmartContractAddressesListGetResult::SmartContractAddressesListGetResult( SmartContractAddressesListGetResult&& other185) {
  status = std::move(other185.status);
  addressesList = std::move(other185.addressesList);
  __isset = std::move(other185.__isset);
}
SmartContractAddressesListGetResult& SmartContractAddressesListGetResult::operator=(const SmartContractAddressesListGetResult& other186) {
  status = other186.status;
  addressesList = other186.addressesList;
  __isset = other186.__isset;
  return *this;
}
SmartContractAddressesListGetResult& SmartContractAddressesListGetResult::operator=(SmartContractAddressesListGetResult&& other187) {
  status = std::move(other187.status);
  addressesList = std::move(other187.addressesList);
  __isset = std::move(other187.__isset);
  return *this;
}
void SmartContractAddressesListGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContractAddressesListGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "addressesList=" << to_string(addressesList);
  out << ")";
}


SmartContractsListGetResult::~SmartContractsListGetResult() throw() {
}


void SmartContractsListGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void SmartContractsListGetResult::__set_count(const int32_t val) {
  this->count = val;
}

void SmartContractsListGetResult::__set_smartContractsList(const std::vector<SmartContract> & val) {
  this->smartContractsList = val;
}
std::ostream& operator<<(std::ostream& out, const SmartContractsListGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContractsListGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->smartContractsList.clear();
            uint32_t _size188;
            ::apache::thrift::protocol::TType _etype191;
            xfer += iprot->readListBegin(_etype191, _size188);
            this->smartContractsList.resize(_size188);
            uint32_t _i192;
            for (_i192 = 0; _i192 < _size188; ++_i192)
            {
              xfer += this->smartContractsList[_i192].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.smartContractsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartContractsListGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContractsListGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("smartContractsList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->smartContractsList.size()));
    std::vector<SmartContract> ::const_iterator _iter193;
    for (_iter193 = this->smartContractsList.begin(); _iter193 != this->smartContractsList.end(); ++_iter193)
    {
      xfer += (*_iter193).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContractsListGetResult &a, SmartContractsListGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.count, b.count);
  swap(a.smartContractsList, b.smartContractsList);
  swap(a.__isset, b.__isset);
}

SmartContractsListGetResult::SmartContractsListGetResult(const SmartContractsListGetResult& other194) {
  status = other194.status;
  count = other194.count;
  smartContractsList = other194.smartContractsList;
  __isset = other194.__isset;
}
SmartContractsListGetResult::SmartContractsListGetResult( SmartContractsListGetResult&& other195) {
  status = std::move(other195.status);
  count = std::move(other195.count);
  smartContractsList = std::move(other195.smartContractsList);
  __isset = std::move(other195.__isset);
}
SmartContractsListGetResult& SmartContractsListGetResult::operator=(const SmartContractsListGetResult& other196) {
  status = other196.status;
  count = other196.count;
  smartContractsList = other196.smartContractsList;
  __isset = other196.__isset;
  return *this;
}
SmartContractsListGetResult& SmartContractsListGetResult::operator=(SmartContractsListGetResult&& other197) {
  status = std::move(other197.status);
  count = std::move(other197.count);
  smartContractsList = std::move(other197.smartContractsList);
  __isset = std::move(other197.__isset);
  return *this;
}
void SmartContractsListGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContractsListGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "count=" << to_string(count);
  out << ", " << "smartContractsList=" << to_string(smartContractsList);
  out << ")";
}


TransactionsStateGetResult::~TransactionsStateGetResult() throw() {
}


void TransactionsStateGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void TransactionsStateGetResult::__set_states(const std::map<TransactionInnerId, TransactionState> & val) {
  this->states = val;
}

void TransactionsStateGetResult::__set_roundNum(const int32_t val) {
  this->roundNum = val;
}
std::ostream& operator<<(std::ostream& out, const TransactionsStateGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TransactionsStateGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->states.clear();
            uint32_t _size198;
            ::apache::thrift::protocol::TType _ktype199;
            ::apache::thrift::protocol::TType _vtype200;
            xfer += iprot->readMapBegin(_ktype199, _vtype200, _size198);
            uint32_t _i202;
            for (_i202 = 0; _i202 < _size198; ++_i202)
            {
              TransactionInnerId _key203;
              xfer += iprot->readI64(_key203);
              TransactionState& _val204 = this->states[_key203];
              int32_t ecast205;
              xfer += iprot->readI32(ecast205);
              _val204 = (TransactionState)ecast205;
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.states = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->roundNum);
          this->__isset.roundNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TransactionsStateGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TransactionsStateGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("states", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->states.size()));
    std::map<TransactionInnerId, TransactionState> ::const_iterator _iter206;
    for (_iter206 = this->states.begin(); _iter206 != this->states.end(); ++_iter206)
    {
      xfer += oprot->writeI64(_iter206->first);
      xfer += oprot->writeI32((int32_t)_iter206->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roundNum", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->roundNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransactionsStateGetResult &a, TransactionsStateGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.states, b.states);
  swap(a.roundNum, b.roundNum);
  swap(a.__isset, b.__isset);
}

TransactionsStateGetResult::TransactionsStateGetResult(const TransactionsStateGetResult& other207) {
  status = other207.status;
  states = other207.states;
  roundNum = other207.roundNum;
  __isset = other207.__isset;
}
TransactionsStateGetResult::TransactionsStateGetResult( TransactionsStateGetResult&& other208) {
  status = std::move(other208.status);
  states = std::move(other208.states);
  roundNum = std::move(other208.roundNum);
  __isset = std::move(other208.__isset);
}
TransactionsStateGetResult& TransactionsStateGetResult::operator=(const TransactionsStateGetResult& other209) {
  status = other209.status;
  states = other209.states;
  roundNum = other209.roundNum;
  __isset = other209.__isset;
  return *this;
}
TransactionsStateGetResult& TransactionsStateGetResult::operator=(TransactionsStateGetResult&& other210) {
  status = std::move(other210.status);
  states = std::move(other210.states);
  roundNum = std::move(other210.roundNum);
  __isset = std::move(other210.__isset);
  return *this;
}
void TransactionsStateGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TransactionsStateGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "states=" << to_string(states);
  out << ", " << "roundNum=" << to_string(roundNum);
  out << ")";
}


SmartMethodParamsGetResult::~SmartMethodParamsGetResult() throw() {
}


void SmartMethodParamsGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void SmartMethodParamsGetResult::__set_method(const std::string& val) {
  this->method = val;
}

void SmartMethodParamsGetResult::__set_params(const std::vector< ::general::Variant> & val) {
  this->params = val;
}
std::ostream& operator<<(std::ostream& out, const SmartMethodParamsGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartMethodParamsGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method);
          this->__isset.method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->params.clear();
            uint32_t _size211;
            ::apache::thrift::protocol::TType _etype214;
            xfer += iprot->readListBegin(_etype214, _size211);
            this->params.resize(_size211);
            uint32_t _i215;
            for (_i215 = 0; _i215 < _size211; ++_i215)
            {
              xfer += this->params[_i215].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartMethodParamsGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartMethodParamsGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->params.size()));
    std::vector< ::general::Variant> ::const_iterator _iter216;
    for (_iter216 = this->params.begin(); _iter216 != this->params.end(); ++_iter216)
    {
      xfer += (*_iter216).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartMethodParamsGetResult &a, SmartMethodParamsGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.method, b.method);
  swap(a.params, b.params);
  swap(a.__isset, b.__isset);
}

SmartMethodParamsGetResult::SmartMethodParamsGetResult(const SmartMethodParamsGetResult& other217) {
  status = other217.status;
  method = other217.method;
  params = other217.params;
  __isset = other217.__isset;
}
SmartMethodParamsGetResult::SmartMethodParamsGetResult( SmartMethodParamsGetResult&& other218) {
  status = std::move(other218.status);
  method = std::move(other218.method);
  params = std::move(other218.params);
  __isset = std::move(other218.__isset);
}
SmartMethodParamsGetResult& SmartMethodParamsGetResult::operator=(const SmartMethodParamsGetResult& other219) {
  status = other219.status;
  method = other219.method;
  params = other219.params;
  __isset = other219.__isset;
  return *this;
}
SmartMethodParamsGetResult& SmartMethodParamsGetResult::operator=(SmartMethodParamsGetResult&& other220) {
  status = std::move(other220.status);
  method = std::move(other220.method);
  params = std::move(other220.params);
  __isset = std::move(other220.__isset);
  return *this;
}
void SmartMethodParamsGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartMethodParamsGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "method=" << to_string(method);
  out << ", " << "params=" << to_string(params);
  out << ")";
}


ContractAllMethodsGetResult::~ContractAllMethodsGetResult() throw() {
}


void ContractAllMethodsGetResult::__set_code(const int8_t val) {
  this->code = val;
}

void ContractAllMethodsGetResult::__set_message(const std::string& val) {
  this->message = val;
}

void ContractAllMethodsGetResult::__set_methods(const std::vector< ::general::MethodDescription> & val) {
  this->methods = val;
}
std::ostream& operator<<(std::ostream& out, const ContractAllMethodsGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ContractAllMethodsGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->methods.clear();
            uint32_t _size221;
            ::apache::thrift::protocol::TType _etype224;
            xfer += iprot->readListBegin(_etype224, _size221);
            this->methods.resize(_size221);
            uint32_t _i225;
            for (_i225 = 0; _i225 < _size221; ++_i225)
            {
              xfer += this->methods[_i225].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.methods = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContractAllMethodsGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ContractAllMethodsGetResult");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("methods", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->methods.size()));
    std::vector< ::general::MethodDescription> ::const_iterator _iter226;
    for (_iter226 = this->methods.begin(); _iter226 != this->methods.end(); ++_iter226)
    {
      xfer += (*_iter226).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContractAllMethodsGetResult &a, ContractAllMethodsGetResult &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.methods, b.methods);
  swap(a.__isset, b.__isset);
}

ContractAllMethodsGetResult::ContractAllMethodsGetResult(const ContractAllMethodsGetResult& other227) {
  code = other227.code;
  message = other227.message;
  methods = other227.methods;
  __isset = other227.__isset;
}
ContractAllMethodsGetResult::ContractAllMethodsGetResult( ContractAllMethodsGetResult&& other228) {
  code = std::move(other228.code);
  message = std::move(other228.message);
  methods = std::move(other228.methods);
  __isset = std::move(other228.__isset);
}
ContractAllMethodsGetResult& ContractAllMethodsGetResult::operator=(const ContractAllMethodsGetResult& other229) {
  code = other229.code;
  message = other229.message;
  methods = other229.methods;
  __isset = other229.__isset;
  return *this;
}
ContractAllMethodsGetResult& ContractAllMethodsGetResult::operator=(ContractAllMethodsGetResult&& other230) {
  code = std::move(other230.code);
  message = std::move(other230.message);
  methods = std::move(other230.methods);
  __isset = std::move(other230.__isset);
  return *this;
}
void ContractAllMethodsGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ContractAllMethodsGetResult(";
  out << "code=" << to_string(code);
  out << ", " << "message=" << to_string(message);
  out << ", " << "methods=" << to_string(methods);
  out << ")";
}


SmartContractMethodArgument::~SmartContractMethodArgument() throw() {
}


void SmartContractMethodArgument::__set_type(const std::string& val) {
  this->type = val;
}

void SmartContractMethodArgument::__set_name(const std::string& val) {
  this->name = val;
}
std::ostream& operator<<(std::ostream& out, const SmartContractMethodArgument& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContractMethodArgument::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartContractMethodArgument::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContractMethodArgument");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContractMethodArgument &a, SmartContractMethodArgument &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

SmartContractMethodArgument::SmartContractMethodArgument(const SmartContractMethodArgument& other231) {
  type = other231.type;
  name = other231.name;
  __isset = other231.__isset;
}
SmartContractMethodArgument::SmartContractMethodArgument( SmartContractMethodArgument&& other232) {
  type = std::move(other232.type);
  name = std::move(other232.name);
  __isset = std::move(other232.__isset);
}
SmartContractMethodArgument& SmartContractMethodArgument::operator=(const SmartContractMethodArgument& other233) {
  type = other233.type;
  name = other233.name;
  __isset = other233.__isset;
  return *this;
}
SmartContractMethodArgument& SmartContractMethodArgument::operator=(SmartContractMethodArgument&& other234) {
  type = std::move(other234.type);
  name = std::move(other234.name);
  __isset = std::move(other234.__isset);
  return *this;
}
void SmartContractMethodArgument::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContractMethodArgument(";
  out << "type=" << to_string(type);
  out << ", " << "name=" << to_string(name);
  out << ")";
}


SmartContractMethod::~SmartContractMethod() throw() {
}


void SmartContractMethod::__set_returnType(const std::string& val) {
  this->returnType = val;
}

void SmartContractMethod::__set_name(const std::string& val) {
  this->name = val;
}

void SmartContractMethod::__set_arguments(const std::vector<SmartContractMethodArgument> & val) {
  this->arguments = val;
}
std::ostream& operator<<(std::ostream& out, const SmartContractMethod& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContractMethod::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->returnType);
          this->__isset.returnType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arguments.clear();
            uint32_t _size235;
            ::apache::thrift::protocol::TType _etype238;
            xfer += iprot->readListBegin(_etype238, _size235);
            this->arguments.resize(_size235);
            uint32_t _i239;
            for (_i239 = 0; _i239 < _size235; ++_i239)
            {
              xfer += this->arguments[_i239].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arguments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartContractMethod::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContractMethod");

  xfer += oprot->writeFieldBegin("returnType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->returnType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arguments.size()));
    std::vector<SmartContractMethodArgument> ::const_iterator _iter240;
    for (_iter240 = this->arguments.begin(); _iter240 != this->arguments.end(); ++_iter240)
    {
      xfer += (*_iter240).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContractMethod &a, SmartContractMethod &b) {
  using ::std::swap;
  swap(a.returnType, b.returnType);
  swap(a.name, b.name);
  swap(a.arguments, b.arguments);
  swap(a.__isset, b.__isset);
}

SmartContractMethod::SmartContractMethod(const SmartContractMethod& other241) {
  returnType = other241.returnType;
  name = other241.name;
  arguments = other241.arguments;
  __isset = other241.__isset;
}
SmartContractMethod::SmartContractMethod( SmartContractMethod&& other242) {
  returnType = std::move(other242.returnType);
  name = std::move(other242.name);
  arguments = std::move(other242.arguments);
  __isset = std::move(other242.__isset);
}
SmartContractMethod& SmartContractMethod::operator=(const SmartContractMethod& other243) {
  returnType = other243.returnType;
  name = other243.name;
  arguments = other243.arguments;
  __isset = other243.__isset;
  return *this;
}
SmartContractMethod& SmartContractMethod::operator=(SmartContractMethod&& other244) {
  returnType = std::move(other244.returnType);
  name = std::move(other244.name);
  arguments = std::move(other244.arguments);
  __isset = std::move(other244.__isset);
  return *this;
}
void SmartContractMethod::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContractMethod(";
  out << "returnType=" << to_string(returnType);
  out << ", " << "name=" << to_string(name);
  out << ", " << "arguments=" << to_string(arguments);
  out << ")";
}


SmartContractDataResult::~SmartContractDataResult() throw() {
}


void SmartContractDataResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void SmartContractDataResult::__set_methods(const std::vector<SmartContractMethod> & val) {
  this->methods = val;
}

void SmartContractDataResult::__set_variables(const std::map<std::string,  ::general::Variant> & val) {
  this->variables = val;
}
std::ostream& operator<<(std::ostream& out, const SmartContractDataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContractDataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->methods.clear();
            uint32_t _size245;
            ::apache::thrift::protocol::TType _etype248;
            xfer += iprot->readListBegin(_etype248, _size245);
            this->methods.resize(_size245);
            uint32_t _i249;
            for (_i249 = 0; _i249 < _size245; ++_i249)
            {
              xfer += this->methods[_i249].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.methods = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->variables.clear();
            uint32_t _size250;
            ::apache::thrift::protocol::TType _ktype251;
            ::apache::thrift::protocol::TType _vtype252;
            xfer += iprot->readMapBegin(_ktype251, _vtype252, _size250);
            uint32_t _i254;
            for (_i254 = 0; _i254 < _size250; ++_i254)
            {
              std::string _key255;
              xfer += iprot->readString(_key255);
               ::general::Variant& _val256 = this->variables[_key255];
              xfer += _val256.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.variables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartContractDataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContractDataResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("methods", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->methods.size()));
    std::vector<SmartContractMethod> ::const_iterator _iter257;
    for (_iter257 = this->methods.begin(); _iter257 != this->methods.end(); ++_iter257)
    {
      xfer += (*_iter257).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("variables", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->variables.size()));
    std::map<std::string,  ::general::Variant> ::const_iterator _iter258;
    for (_iter258 = this->variables.begin(); _iter258 != this->variables.end(); ++_iter258)
    {
      xfer += oprot->writeString(_iter258->first);
      xfer += _iter258->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContractDataResult &a, SmartContractDataResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.methods, b.methods);
  swap(a.variables, b.variables);
  swap(a.__isset, b.__isset);
}

SmartContractDataResult::SmartContractDataResult(const SmartContractDataResult& other259) {
  status = other259.status;
  methods = other259.methods;
  variables = other259.variables;
  __isset = other259.__isset;
}
SmartContractDataResult::SmartContractDataResult( SmartContractDataResult&& other260) {
  status = std::move(other260.status);
  methods = std::move(other260.methods);
  variables = std::move(other260.variables);
  __isset = std::move(other260.__isset);
}
SmartContractDataResult& SmartContractDataResult::operator=(const SmartContractDataResult& other261) {
  status = other261.status;
  methods = other261.methods;
  variables = other261.variables;
  __isset = other261.__isset;
  return *this;
}
SmartContractDataResult& SmartContractDataResult::operator=(SmartContractDataResult&& other262) {
  status = std::move(other262.status);
  methods = std::move(other262.methods);
  variables = std::move(other262.variables);
  __isset = std::move(other262.__isset);
  return *this;
}
void SmartContractDataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContractDataResult(";
  out << "status=" << to_string(status);
  out << ", " << "methods=" << to_string(methods);
  out << ", " << "variables=" << to_string(variables);
  out << ")";
}


SmartContractCompileResult::~SmartContractCompileResult() throw() {
}


void SmartContractCompileResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void SmartContractCompileResult::__set_byteCodeObjects(const std::vector< ::general::ByteCodeObject> & val) {
  this->byteCodeObjects = val;
}

void SmartContractCompileResult::__set_ts(const TokenStandart val) {
  this->ts = val;
}
std::ostream& operator<<(std::ostream& out, const SmartContractCompileResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContractCompileResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->byteCodeObjects.clear();
            uint32_t _size263;
            ::apache::thrift::protocol::TType _etype266;
            xfer += iprot->readListBegin(_etype266, _size263);
            this->byteCodeObjects.resize(_size263);
            uint32_t _i267;
            for (_i267 = 0; _i267 < _size263; ++_i267)
            {
              xfer += this->byteCodeObjects[_i267].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.byteCodeObjects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast268;
          xfer += iprot->readI32(ecast268);
          this->ts = (TokenStandart)ecast268;
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartContractCompileResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContractCompileResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteCodeObjects", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->byteCodeObjects.size()));
    std::vector< ::general::ByteCodeObject> ::const_iterator _iter269;
    for (_iter269 = this->byteCodeObjects.begin(); _iter269 != this->byteCodeObjects.end(); ++_iter269)
    {
      xfer += (*_iter269).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContractCompileResult &a, SmartContractCompileResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.byteCodeObjects, b.byteCodeObjects);
  swap(a.ts, b.ts);
  swap(a.__isset, b.__isset);
}

SmartContractCompileResult::SmartContractCompileResult(const SmartContractCompileResult& other270) {
  status = other270.status;
  byteCodeObjects = other270.byteCodeObjects;
  ts = other270.ts;
  __isset = other270.__isset;
}
SmartContractCompileResult::SmartContractCompileResult( SmartContractCompileResult&& other271) {
  status = std::move(other271.status);
  byteCodeObjects = std::move(other271.byteCodeObjects);
  ts = std::move(other271.ts);
  __isset = std::move(other271.__isset);
}
SmartContractCompileResult& SmartContractCompileResult::operator=(const SmartContractCompileResult& other272) {
  status = other272.status;
  byteCodeObjects = other272.byteCodeObjects;
  ts = other272.ts;
  __isset = other272.__isset;
  return *this;
}
SmartContractCompileResult& SmartContractCompileResult::operator=(SmartContractCompileResult&& other273) {
  status = std::move(other273.status);
  byteCodeObjects = std::move(other273.byteCodeObjects);
  ts = std::move(other273.ts);
  __isset = std::move(other273.__isset);
  return *this;
}
void SmartContractCompileResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContractCompileResult(";
  out << "status=" << to_string(status);
  out << ", " << "byteCodeObjects=" << to_string(byteCodeObjects);
  out << ", " << "ts=" << to_string(ts);
  out << ")";
}


TokenInfo::~TokenInfo() throw() {
}


void TokenInfo::__set_address(const Address& val) {
  this->address = val;
}

void TokenInfo::__set_code(const TokenCode& val) {
  this->code = val;
}

void TokenInfo::__set_name(const std::string& val) {
  this->name = val;
}

void TokenInfo::__set_totalSupply(const TokenAmount& val) {
  this->totalSupply = val;
}

void TokenInfo::__set_owner(const Address& val) {
  this->owner = val;
}

void TokenInfo::__set_transfersCount(const int32_t val) {
  this->transfersCount = val;
}

void TokenInfo::__set_transactionsCount(const int32_t val) {
  this->transactionsCount = val;
}

void TokenInfo::__set_holdersCount(const int32_t val) {
  this->holdersCount = val;
}

void TokenInfo::__set_standart(const TokenStandart val) {
  this->standart = val;
}
std::ostream& operator<<(std::ostream& out, const TokenInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TokenInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->address);
          this->__isset.address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->totalSupply);
          this->__isset.totalSupply = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->owner);
          this->__isset.owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->transfersCount);
          this->__isset.transfersCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->transactionsCount);
          this->__isset.transactionsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->holdersCount);
          this->__isset.holdersCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast274;
          xfer += iprot->readI32(ecast274);
          this->standart = (TokenStandart)ecast274;
          this->__isset.standart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TokenInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TokenInfo");

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->address);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalSupply", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->totalSupply);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transfersCount", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->transfersCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactionsCount", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->transactionsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("holdersCount", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->holdersCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("standart", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32((int32_t)this->standart);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenInfo &a, TokenInfo &b) {
  using ::std::swap;
  swap(a.address, b.address);
  swap(a.code, b.code);
  swap(a.name, b.name);
  swap(a.totalSupply, b.totalSupply);
  swap(a.owner, b.owner);
  swap(a.transfersCount, b.transfersCount);
  swap(a.transactionsCount, b.transactionsCount);
  swap(a.holdersCount, b.holdersCount);
  swap(a.standart, b.standart);
  swap(a.__isset, b.__isset);
}

TokenInfo::TokenInfo(const TokenInfo& other275) {
  address = other275.address;
  code = other275.code;
  name = other275.name;
  totalSupply = other275.totalSupply;
  owner = other275.owner;
  transfersCount = other275.transfersCount;
  transactionsCount = other275.transactionsCount;
  holdersCount = other275.holdersCount;
  standart = other275.standart;
  __isset = other275.__isset;
}
TokenInfo::TokenInfo( TokenInfo&& other276) {
  address = std::move(other276.address);
  code = std::move(other276.code);
  name = std::move(other276.name);
  totalSupply = std::move(other276.totalSupply);
  owner = std::move(other276.owner);
  transfersCount = std::move(other276.transfersCount);
  transactionsCount = std::move(other276.transactionsCount);
  holdersCount = std::move(other276.holdersCount);
  standart = std::move(other276.standart);
  __isset = std::move(other276.__isset);
}
TokenInfo& TokenInfo::operator=(const TokenInfo& other277) {
  address = other277.address;
  code = other277.code;
  name = other277.name;
  totalSupply = other277.totalSupply;
  owner = other277.owner;
  transfersCount = other277.transfersCount;
  transactionsCount = other277.transactionsCount;
  holdersCount = other277.holdersCount;
  standart = other277.standart;
  __isset = other277.__isset;
  return *this;
}
TokenInfo& TokenInfo::operator=(TokenInfo&& other278) {
  address = std::move(other278.address);
  code = std::move(other278.code);
  name = std::move(other278.name);
  totalSupply = std::move(other278.totalSupply);
  owner = std::move(other278.owner);
  transfersCount = std::move(other278.transfersCount);
  transactionsCount = std::move(other278.transactionsCount);
  holdersCount = std::move(other278.holdersCount);
  standart = std::move(other278.standart);
  __isset = std::move(other278.__isset);
  return *this;
}
void TokenInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TokenInfo(";
  out << "address=" << to_string(address);
  out << ", " << "code=" << to_string(code);
  out << ", " << "name=" << to_string(name);
  out << ", " << "totalSupply=" << to_string(totalSupply);
  out << ", " << "owner=" << to_string(owner);
  out << ", " << "transfersCount=" << to_string(transfersCount);
  out << ", " << "transactionsCount=" << to_string(transactionsCount);
  out << ", " << "holdersCount=" << to_string(holdersCount);
  out << ", " << "standart=" << to_string(standart);
  out << ")";
}


TokenTransaction::~TokenTransaction() throw() {
}


void TokenTransaction::__set_token(const Address& val) {
  this->token = val;
}

void TokenTransaction::__set_transaction(const TransactionId& val) {
  this->transaction = val;
}

void TokenTransaction::__set_time(const Time val) {
  this->time = val;
}

void TokenTransaction::__set_initiator(const Address& val) {
  this->initiator = val;
}

void TokenTransaction::__set_method(const std::string& val) {
  this->method = val;
}

void TokenTransaction::__set_params(const std::vector< ::general::Variant> & val) {
  this->params = val;
}
std::ostream& operator<<(std::ostream& out, const TokenTransaction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TokenTransaction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transaction.read(iprot);
          this->__isset.transaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->initiator);
          this->__isset.initiator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method);
          this->__isset.method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->params.clear();
            uint32_t _size279;
            ::apache::thrift::protocol::TType _etype282;
            xfer += iprot->readListBegin(_etype282, _size279);
            this->params.resize(_size279);
            uint32_t _i283;
            for (_i283 = 0; _i283 < _size279; ++_i283)
            {
              xfer += this->params[_i283].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TokenTransaction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TokenTransaction");

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transaction", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->transaction.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("initiator", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->initiator);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->params.size()));
    std::vector< ::general::Variant> ::const_iterator _iter284;
    for (_iter284 = this->params.begin(); _iter284 != this->params.end(); ++_iter284)
    {
      xfer += (*_iter284).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenTransaction &a, TokenTransaction &b) {
  using ::std::swap;
  swap(a.token, b.token);
  swap(a.transaction, b.transaction);
  swap(a.time, b.time);
  swap(a.initiator, b.initiator);
  swap(a.method, b.method);
  swap(a.params, b.params);
  swap(a.__isset, b.__isset);
}

TokenTransaction::TokenTransaction(const TokenTransaction& other285) {
  token = other285.token;
  transaction = other285.transaction;
  time = other285.time;
  initiator = other285.initiator;
  method = other285.method;
  params = other285.params;
  __isset = other285.__isset;
}
TokenTransaction::TokenTransaction( TokenTransaction&& other286) {
  token = std::move(other286.token);
  transaction = std::move(other286.transaction);
  time = std::move(other286.time);
  initiator = std::move(other286.initiator);
  method = std::move(other286.method);
  params = std::move(other286.params);
  __isset = std::move(other286.__isset);
}
TokenTransaction& TokenTransaction::operator=(const TokenTransaction& other287) {
  token = other287.token;
  transaction = other287.transaction;
  time = other287.time;
  initiator = other287.initiator;
  method = other287.method;
  params = other287.params;
  __isset = other287.__isset;
  return *this;
}
TokenTransaction& TokenTransaction::operator=(TokenTransaction&& other288) {
  token = std::move(other288.token);
  transaction = std::move(other288.transaction);
  time = std::move(other288.time);
  initiator = std::move(other288.initiator);
  method = std::move(other288.method);
  params = std::move(other288.params);
  __isset = std::move(other288.__isset);
  return *this;
}
void TokenTransaction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TokenTransaction(";
  out << "token=" << to_string(token);
  out << ", " << "transaction=" << to_string(transaction);
  out << ", " << "time=" << to_string(time);
  out << ", " << "initiator=" << to_string(initiator);
  out << ", " << "method=" << to_string(method);
  out << ", " << "params=" << to_string(params);
  out << ")";
}


TokenHolder::~TokenHolder() throw() {
}


void TokenHolder::__set_holder(const Address& val) {
  this->holder = val;
}

void TokenHolder::__set_token(const Address& val) {
  this->token = val;
}

void TokenHolder::__set_balance(const TokenAmount& val) {
  this->balance = val;
}

void TokenHolder::__set_transfersCount(const int32_t val) {
  this->transfersCount = val;
}
std::ostream& operator<<(std::ostream& out, const TokenHolder& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TokenHolder::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->holder);
          this->__isset.holder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->balance);
          this->__isset.balance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->transfersCount);
          this->__isset.transfersCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TokenHolder::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TokenHolder");

  xfer += oprot->writeFieldBegin("holder", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->holder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("balance", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->balance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transfersCount", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->transfersCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenHolder &a, TokenHolder &b) {
  using ::std::swap;
  swap(a.holder, b.holder);
  swap(a.token, b.token);
  swap(a.balance, b.balance);
  swap(a.transfersCount, b.transfersCount);
  swap(a.__isset, b.__isset);
}

TokenHolder::TokenHolder(const TokenHolder& other289) {
  holder = other289.holder;
  token = other289.token;
  balance = other289.balance;
  transfersCount = other289.transfersCount;
  __isset = other289.__isset;
}
TokenHolder::TokenHolder( TokenHolder&& other290) {
  holder = std::move(other290.holder);
  token = std::move(other290.token);
  balance = std::move(other290.balance);
  transfersCount = std::move(other290.transfersCount);
  __isset = std::move(other290.__isset);
}
TokenHolder& TokenHolder::operator=(const TokenHolder& other291) {
  holder = other291.holder;
  token = other291.token;
  balance = other291.balance;
  transfersCount = other291.transfersCount;
  __isset = other291.__isset;
  return *this;
}
TokenHolder& TokenHolder::operator=(TokenHolder&& other292) {
  holder = std::move(other292.holder);
  token = std::move(other292.token);
  balance = std::move(other292.balance);
  transfersCount = std::move(other292.transfersCount);
  __isset = std::move(other292.__isset);
  return *this;
}
void TokenHolder::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TokenHolder(";
  out << "holder=" << to_string(holder);
  out << ", " << "token=" << to_string(token);
  out << ", " << "balance=" << to_string(balance);
  out << ", " << "transfersCount=" << to_string(transfersCount);
  out << ")";
}


TokenBalance::~TokenBalance() throw() {
}


void TokenBalance::__set_token(const Address& val) {
  this->token = val;
}

void TokenBalance::__set_code(const TokenCode& val) {
  this->code = val;
}

void TokenBalance::__set_name(const std::string& val) {
  this->name = val;
}

void TokenBalance::__set_balance(const TokenAmount& val) {
  this->balance = val;
}
std::ostream& operator<<(std::ostream& out, const TokenBalance& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TokenBalance::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->balance);
          this->__isset.balance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TokenBalance::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TokenBalance");

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("balance", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->balance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenBalance &a, TokenBalance &b) {
  using ::std::swap;
  swap(a.token, b.token);
  swap(a.code, b.code);
  swap(a.name, b.name);
  swap(a.balance, b.balance);
  swap(a.__isset, b.__isset);
}

TokenBalance::TokenBalance(const TokenBalance& other293) {
  token = other293.token;
  code = other293.code;
  name = other293.name;
  balance = other293.balance;
  __isset = other293.__isset;
}
TokenBalance::TokenBalance( TokenBalance&& other294) {
  token = std::move(other294.token);
  code = std::move(other294.code);
  name = std::move(other294.name);
  balance = std::move(other294.balance);
  __isset = std::move(other294.__isset);
}
TokenBalance& TokenBalance::operator=(const TokenBalance& other295) {
  token = other295.token;
  code = other295.code;
  name = other295.name;
  balance = other295.balance;
  __isset = other295.__isset;
  return *this;
}
TokenBalance& TokenBalance::operator=(TokenBalance&& other296) {
  token = std::move(other296.token);
  code = std::move(other296.code);
  name = std::move(other296.name);
  balance = std::move(other296.balance);
  __isset = std::move(other296.__isset);
  return *this;
}
void TokenBalance::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TokenBalance(";
  out << "token=" << to_string(token);
  out << ", " << "code=" << to_string(code);
  out << ", " << "name=" << to_string(name);
  out << ", " << "balance=" << to_string(balance);
  out << ")";
}


TokenBalancesResult::~TokenBalancesResult() throw() {
}


void TokenBalancesResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void TokenBalancesResult::__set_balances(const std::vector<TokenBalance> & val) {
  this->balances = val;
}
std::ostream& operator<<(std::ostream& out, const TokenBalancesResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TokenBalancesResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->balances.clear();
            uint32_t _size297;
            ::apache::thrift::protocol::TType _etype300;
            xfer += iprot->readListBegin(_etype300, _size297);
            this->balances.resize(_size297);
            uint32_t _i301;
            for (_i301 = 0; _i301 < _size297; ++_i301)
            {
              xfer += this->balances[_i301].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.balances = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TokenBalancesResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TokenBalancesResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("balances", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->balances.size()));
    std::vector<TokenBalance> ::const_iterator _iter302;
    for (_iter302 = this->balances.begin(); _iter302 != this->balances.end(); ++_iter302)
    {
      xfer += (*_iter302).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenBalancesResult &a, TokenBalancesResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.balances, b.balances);
  swap(a.__isset, b.__isset);
}

TokenBalancesResult::TokenBalancesResult(const TokenBalancesResult& other303) {
  status = other303.status;
  balances = other303.balances;
  __isset = other303.__isset;
}
TokenBalancesResult::TokenBalancesResult( TokenBalancesResult&& other304) {
  status = std::move(other304.status);
  balances = std::move(other304.balances);
  __isset = std::move(other304.__isset);
}
TokenBalancesResult& TokenBalancesResult::operator=(const TokenBalancesResult& other305) {
  status = other305.status;
  balances = other305.balances;
  __isset = other305.__isset;
  return *this;
}
TokenBalancesResult& TokenBalancesResult::operator=(TokenBalancesResult&& other306) {
  status = std::move(other306.status);
  balances = std::move(other306.balances);
  __isset = std::move(other306.__isset);
  return *this;
}
void TokenBalancesResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TokenBalancesResult(";
  out << "status=" << to_string(status);
  out << ", " << "balances=" << to_string(balances);
  out << ")";
}


TokenTransfer::~TokenTransfer() throw() {
}


void TokenTransfer::__set_token(const Address& val) {
  this->token = val;
}

void TokenTransfer::__set_code(const TokenCode& val) {
  this->code = val;
}

void TokenTransfer::__set_sender(const Address& val) {
  this->sender = val;
}

void TokenTransfer::__set_receiver(const Address& val) {
  this->receiver = val;
}

void TokenTransfer::__set_amount(const TokenAmount& val) {
  this->amount = val;
}

void TokenTransfer::__set_initiator(const Address& val) {
  this->initiator = val;
}

void TokenTransfer::__set_transaction(const TransactionId& val) {
  this->transaction = val;
}

void TokenTransfer::__set_time(const Time val) {
  this->time = val;
}
std::ostream& operator<<(std::ostream& out, const TokenTransfer& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TokenTransfer::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sender);
          this->__isset.sender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->receiver);
          this->__isset.receiver = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->amount);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->initiator);
          this->__isset.initiator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transaction.read(iprot);
          this->__isset.transaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TokenTransfer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TokenTransfer");

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sender", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->sender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("receiver", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->receiver);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->amount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("initiator", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->initiator);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transaction", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->transaction.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenTransfer &a, TokenTransfer &b) {
  using ::std::swap;
  swap(a.token, b.token);
  swap(a.code, b.code);
  swap(a.sender, b.sender);
  swap(a.receiver, b.receiver);
  swap(a.amount, b.amount);
  swap(a.initiator, b.initiator);
  swap(a.transaction, b.transaction);
  swap(a.time, b.time);
  swap(a.__isset, b.__isset);
}

TokenTransfer::TokenTransfer(const TokenTransfer& other307) {
  token = other307.token;
  code = other307.code;
  sender = other307.sender;
  receiver = other307.receiver;
  amount = other307.amount;
  initiator = other307.initiator;
  transaction = other307.transaction;
  time = other307.time;
  __isset = other307.__isset;
}
TokenTransfer::TokenTransfer( TokenTransfer&& other308) {
  token = std::move(other308.token);
  code = std::move(other308.code);
  sender = std::move(other308.sender);
  receiver = std::move(other308.receiver);
  amount = std::move(other308.amount);
  initiator = std::move(other308.initiator);
  transaction = std::move(other308.transaction);
  time = std::move(other308.time);
  __isset = std::move(other308.__isset);
}
TokenTransfer& TokenTransfer::operator=(const TokenTransfer& other309) {
  token = other309.token;
  code = other309.code;
  sender = other309.sender;
  receiver = other309.receiver;
  amount = other309.amount;
  initiator = other309.initiator;
  transaction = other309.transaction;
  time = other309.time;
  __isset = other309.__isset;
  return *this;
}
TokenTransfer& TokenTransfer::operator=(TokenTransfer&& other310) {
  token = std::move(other310.token);
  code = std::move(other310.code);
  sender = std::move(other310.sender);
  receiver = std::move(other310.receiver);
  amount = std::move(other310.amount);
  initiator = std::move(other310.initiator);
  transaction = std::move(other310.transaction);
  time = std::move(other310.time);
  __isset = std::move(other310.__isset);
  return *this;
}
void TokenTransfer::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TokenTransfer(";
  out << "token=" << to_string(token);
  out << ", " << "code=" << to_string(code);
  out << ", " << "sender=" << to_string(sender);
  out << ", " << "receiver=" << to_string(receiver);
  out << ", " << "amount=" << to_string(amount);
  out << ", " << "initiator=" << to_string(initiator);
  out << ", " << "transaction=" << to_string(transaction);
  out << ", " << "time=" << to_string(time);
  out << ")";
}


TokenTransfersResult::~TokenTransfersResult() throw() {
}


void TokenTransfersResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void TokenTransfersResult::__set_count(const int32_t val) {
  this->count = val;
}

void TokenTransfersResult::__set_transfers(const std::vector<TokenTransfer> & val) {
  this->transfers = val;
}
std::ostream& operator<<(std::ostream& out, const TokenTransfersResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TokenTransfersResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->transfers.clear();
            uint32_t _size311;
            ::apache::thrift::protocol::TType _etype314;
            xfer += iprot->readListBegin(_etype314, _size311);
            this->transfers.resize(_size311);
            uint32_t _i315;
            for (_i315 = 0; _i315 < _size311; ++_i315)
            {
              xfer += this->transfers[_i315].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.transfers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TokenTransfersResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TokenTransfersResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transfers", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->transfers.size()));
    std::vector<TokenTransfer> ::const_iterator _iter316;
    for (_iter316 = this->transfers.begin(); _iter316 != this->transfers.end(); ++_iter316)
    {
      xfer += (*_iter316).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenTransfersResult &a, TokenTransfersResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.count, b.count);
  swap(a.transfers, b.transfers);
  swap(a.__isset, b.__isset);
}

TokenTransfersResult::TokenTransfersResult(const TokenTransfersResult& other317) {
  status = other317.status;
  count = other317.count;
  transfers = other317.transfers;
  __isset = other317.__isset;
}
TokenTransfersResult::TokenTransfersResult( TokenTransfersResult&& other318) {
  status = std::move(other318.status);
  count = std::move(other318.count);
  transfers = std::move(other318.transfers);
  __isset = std::move(other318.__isset);
}
TokenTransfersResult& TokenTransfersResult::operator=(const TokenTransfersResult& other319) {
  status = other319.status;
  count = other319.count;
  transfers = other319.transfers;
  __isset = other319.__isset;
  return *this;
}
TokenTransfersResult& TokenTransfersResult::operator=(TokenTransfersResult&& other320) {
  status = std::move(other320.status);
  count = std::move(other320.count);
  transfers = std::move(other320.transfers);
  __isset = std::move(other320.__isset);
  return *this;
}
void TokenTransfersResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TokenTransfersResult(";
  out << "status=" << to_string(status);
  out << ", " << "count=" << to_string(count);
  out << ", " << "transfers=" << to_string(transfers);
  out << ")";
}


TokenTransactionsResult::~TokenTransactionsResult() throw() {
}


void TokenTransactionsResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void TokenTransactionsResult::__set_count(const int32_t val) {
  this->count = val;
}

void TokenTransactionsResult::__set_transactions(const std::vector<TokenTransaction> & val) {
  this->transactions = val;
}
std::ostream& operator<<(std::ostream& out, const TokenTransactionsResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TokenTransactionsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->transactions.clear();
            uint32_t _size321;
            ::apache::thrift::protocol::TType _etype324;
            xfer += iprot->readListBegin(_etype324, _size321);
            this->transactions.resize(_size321);
            uint32_t _i325;
            for (_i325 = 0; _i325 < _size321; ++_i325)
            {
              xfer += this->transactions[_i325].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.transactions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TokenTransactionsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TokenTransactionsResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactions", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->transactions.size()));
    std::vector<TokenTransaction> ::const_iterator _iter326;
    for (_iter326 = this->transactions.begin(); _iter326 != this->transactions.end(); ++_iter326)
    {
      xfer += (*_iter326).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenTransactionsResult &a, TokenTransactionsResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.count, b.count);
  swap(a.transactions, b.transactions);
  swap(a.__isset, b.__isset);
}

TokenTransactionsResult::TokenTransactionsResult(const TokenTransactionsResult& other327) {
  status = other327.status;
  count = other327.count;
  transactions = other327.transactions;
  __isset = other327.__isset;
}
TokenTransactionsResult::TokenTransactionsResult( TokenTransactionsResult&& other328) {
  status = std::move(other328.status);
  count = std::move(other328.count);
  transactions = std::move(other328.transactions);
  __isset = std::move(other328.__isset);
}
TokenTransactionsResult& TokenTransactionsResult::operator=(const TokenTransactionsResult& other329) {
  status = other329.status;
  count = other329.count;
  transactions = other329.transactions;
  __isset = other329.__isset;
  return *this;
}
TokenTransactionsResult& TokenTransactionsResult::operator=(TokenTransactionsResult&& other330) {
  status = std::move(other330.status);
  count = std::move(other330.count);
  transactions = std::move(other330.transactions);
  __isset = std::move(other330.__isset);
  return *this;
}
void TokenTransactionsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TokenTransactionsResult(";
  out << "status=" << to_string(status);
  out << ", " << "count=" << to_string(count);
  out << ", " << "transactions=" << to_string(transactions);
  out << ")";
}


TokenInfoResult::~TokenInfoResult() throw() {
}


void TokenInfoResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void TokenInfoResult::__set_token(const TokenInfo& val) {
  this->token = val;
}
std::ostream& operator<<(std::ostream& out, const TokenInfoResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TokenInfoResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->token.read(iprot);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TokenInfoResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TokenInfoResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->token.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenInfoResult &a, TokenInfoResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.token, b.token);
  swap(a.__isset, b.__isset);
}

TokenInfoResult::TokenInfoResult(const TokenInfoResult& other331) {
  status = other331.status;
  token = other331.token;
  __isset = other331.__isset;
}
TokenInfoResult::TokenInfoResult( TokenInfoResult&& other332) {
  status = std::move(other332.status);
  token = std::move(other332.token);
  __isset = std::move(other332.__isset);
}
TokenInfoResult& TokenInfoResult::operator=(const TokenInfoResult& other333) {
  status = other333.status;
  token = other333.token;
  __isset = other333.__isset;
  return *this;
}
TokenInfoResult& TokenInfoResult::operator=(TokenInfoResult&& other334) {
  status = std::move(other334.status);
  token = std::move(other334.token);
  __isset = std::move(other334.__isset);
  return *this;
}
void TokenInfoResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TokenInfoResult(";
  out << "status=" << to_string(status);
  out << ", " << "token=" << to_string(token);
  out << ")";
}


TokenHoldersResult::~TokenHoldersResult() throw() {
}


void TokenHoldersResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void TokenHoldersResult::__set_count(const int32_t val) {
  this->count = val;
}

void TokenHoldersResult::__set_holders(const std::vector<TokenHolder> & val) {
  this->holders = val;
}
std::ostream& operator<<(std::ostream& out, const TokenHoldersResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TokenHoldersResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->holders.clear();
            uint32_t _size335;
            ::apache::thrift::protocol::TType _etype338;
            xfer += iprot->readListBegin(_etype338, _size335);
            this->holders.resize(_size335);
            uint32_t _i339;
            for (_i339 = 0; _i339 < _size335; ++_i339)
            {
              xfer += this->holders[_i339].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.holders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TokenHoldersResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TokenHoldersResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("holders", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->holders.size()));
    std::vector<TokenHolder> ::const_iterator _iter340;
    for (_iter340 = this->holders.begin(); _iter340 != this->holders.end(); ++_iter340)
    {
      xfer += (*_iter340).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenHoldersResult &a, TokenHoldersResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.count, b.count);
  swap(a.holders, b.holders);
  swap(a.__isset, b.__isset);
}

TokenHoldersResult::TokenHoldersResult(const TokenHoldersResult& other341) {
  status = other341.status;
  count = other341.count;
  holders = other341.holders;
  __isset = other341.__isset;
}
TokenHoldersResult::TokenHoldersResult( TokenHoldersResult&& other342) {
  status = std::move(other342.status);
  count = std::move(other342.count);
  holders = std::move(other342.holders);
  __isset = std::move(other342.__isset);
}
TokenHoldersResult& TokenHoldersResult::operator=(const TokenHoldersResult& other343) {
  status = other343.status;
  count = other343.count;
  holders = other343.holders;
  __isset = other343.__isset;
  return *this;
}
TokenHoldersResult& TokenHoldersResult::operator=(TokenHoldersResult&& other344) {
  status = std::move(other344.status);
  count = std::move(other344.count);
  holders = std::move(other344.holders);
  __isset = std::move(other344.__isset);
  return *this;
}
void TokenHoldersResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TokenHoldersResult(";
  out << "status=" << to_string(status);
  out << ", " << "count=" << to_string(count);
  out << ", " << "holders=" << to_string(holders);
  out << ")";
}


TokensListResult::~TokensListResult() throw() {
}


void TokensListResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void TokensListResult::__set_count(const int32_t val) {
  this->count = val;
}

void TokensListResult::__set_tokens(const std::vector<TokenInfo> & val) {
  this->tokens = val;
}
std::ostream& operator<<(std::ostream& out, const TokensListResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TokensListResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tokens.clear();
            uint32_t _size345;
            ::apache::thrift::protocol::TType _etype348;
            xfer += iprot->readListBegin(_etype348, _size345);
            this->tokens.resize(_size345);
            uint32_t _i349;
            for (_i349 = 0; _i349 < _size345; ++_i349)
            {
              xfer += this->tokens[_i349].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tokens = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TokensListResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TokensListResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tokens", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tokens.size()));
    std::vector<TokenInfo> ::const_iterator _iter350;
    for (_iter350 = this->tokens.begin(); _iter350 != this->tokens.end(); ++_iter350)
    {
      xfer += (*_iter350).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokensListResult &a, TokensListResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.count, b.count);
  swap(a.tokens, b.tokens);
  swap(a.__isset, b.__isset);
}

TokensListResult::TokensListResult(const TokensListResult& other351) {
  status = other351.status;
  count = other351.count;
  tokens = other351.tokens;
  __isset = other351.__isset;
}
TokensListResult::TokensListResult( TokensListResult&& other352) {
  status = std::move(other352.status);
  count = std::move(other352.count);
  tokens = std::move(other352.tokens);
  __isset = std::move(other352.__isset);
}
TokensListResult& TokensListResult::operator=(const TokensListResult& other353) {
  status = other353.status;
  count = other353.count;
  tokens = other353.tokens;
  __isset = other353.__isset;
  return *this;
}
TokensListResult& TokensListResult::operator=(TokensListResult&& other354) {
  status = std::move(other354.status);
  count = std::move(other354.count);
  tokens = std::move(other354.tokens);
  __isset = std::move(other354.__isset);
  return *this;
}
void TokensListResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TokensListResult(";
  out << "status=" << to_string(status);
  out << ", " << "count=" << to_string(count);
  out << ", " << "tokens=" << to_string(tokens);
  out << ")";
}


WalletInfo::~WalletInfo() throw() {
}


void WalletInfo::__set_address(const Address& val) {
  this->address = val;
}

void WalletInfo::__set_balance(const Amount& val) {
  this->balance = val;
}

void WalletInfo::__set_transactionsNumber(const int64_t val) {
  this->transactionsNumber = val;
}

void WalletInfo::__set_firstTransactionTime(const Time val) {
  this->firstTransactionTime = val;
}
std::ostream& operator<<(std::ostream& out, const WalletInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WalletInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->address);
          this->__isset.address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->balance.read(iprot);
          this->__isset.balance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->transactionsNumber);
          this->__isset.transactionsNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->firstTransactionTime);
          this->__isset.firstTransactionTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WalletInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WalletInfo");

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->address);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("balance", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->balance.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactionsNumber", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->transactionsNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstTransactionTime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->firstTransactionTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WalletInfo &a, WalletInfo &b) {
  using ::std::swap;
  swap(a.address, b.address);
  swap(a.balance, b.balance);
  swap(a.transactionsNumber, b.transactionsNumber);
  swap(a.firstTransactionTime, b.firstTransactionTime);
  swap(a.__isset, b.__isset);
}

WalletInfo::WalletInfo(const WalletInfo& other355) {
  address = other355.address;
  balance = other355.balance;
  transactionsNumber = other355.transactionsNumber;
  firstTransactionTime = other355.firstTransactionTime;
  __isset = other355.__isset;
}
WalletInfo::WalletInfo( WalletInfo&& other356) {
  address = std::move(other356.address);
  balance = std::move(other356.balance);
  transactionsNumber = std::move(other356.transactionsNumber);
  firstTransactionTime = std::move(other356.firstTransactionTime);
  __isset = std::move(other356.__isset);
}
WalletInfo& WalletInfo::operator=(const WalletInfo& other357) {
  address = other357.address;
  balance = other357.balance;
  transactionsNumber = other357.transactionsNumber;
  firstTransactionTime = other357.firstTransactionTime;
  __isset = other357.__isset;
  return *this;
}
WalletInfo& WalletInfo::operator=(WalletInfo&& other358) {
  address = std::move(other358.address);
  balance = std::move(other358.balance);
  transactionsNumber = std::move(other358.transactionsNumber);
  firstTransactionTime = std::move(other358.firstTransactionTime);
  __isset = std::move(other358.__isset);
  return *this;
}
void WalletInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WalletInfo(";
  out << "address=" << to_string(address);
  out << ", " << "balance=" << to_string(balance);
  out << ", " << "transactionsNumber=" << to_string(transactionsNumber);
  out << ", " << "firstTransactionTime=" << to_string(firstTransactionTime);
  out << ")";
}


WalletsGetResult::~WalletsGetResult() throw() {
}


void WalletsGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void WalletsGetResult::__set_count(const int32_t val) {
  this->count = val;
}

void WalletsGetResult::__set_wallets(const std::vector<WalletInfo> & val) {
  this->wallets = val;
}
std::ostream& operator<<(std::ostream& out, const WalletsGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WalletsGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->wallets.clear();
            uint32_t _size359;
            ::apache::thrift::protocol::TType _etype362;
            xfer += iprot->readListBegin(_etype362, _size359);
            this->wallets.resize(_size359);
            uint32_t _i363;
            for (_i363 = 0; _i363 < _size359; ++_i363)
            {
              xfer += this->wallets[_i363].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WalletsGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WalletsGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallets", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->wallets.size()));
    std::vector<WalletInfo> ::const_iterator _iter364;
    for (_iter364 = this->wallets.begin(); _iter364 != this->wallets.end(); ++_iter364)
    {
      xfer += (*_iter364).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WalletsGetResult &a, WalletsGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.count, b.count);
  swap(a.wallets, b.wallets);
  swap(a.__isset, b.__isset);
}

WalletsGetResult::WalletsGetResult(const WalletsGetResult& other365) {
  status = other365.status;
  count = other365.count;
  wallets = other365.wallets;
  __isset = other365.__isset;
}
WalletsGetResult::WalletsGetResult( WalletsGetResult&& other366) {
  status = std::move(other366.status);
  count = std::move(other366.count);
  wallets = std::move(other366.wallets);
  __isset = std::move(other366.__isset);
}
WalletsGetResult& WalletsGetResult::operator=(const WalletsGetResult& other367) {
  status = other367.status;
  count = other367.count;
  wallets = other367.wallets;
  __isset = other367.__isset;
  return *this;
}
WalletsGetResult& WalletsGetResult::operator=(WalletsGetResult&& other368) {
  status = std::move(other368.status);
  count = std::move(other368.count);
  wallets = std::move(other368.wallets);
  __isset = std::move(other368.__isset);
  return *this;
}
void WalletsGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WalletsGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "count=" << to_string(count);
  out << ", " << "wallets=" << to_string(wallets);
  out << ")";
}


TrustedInfo::~TrustedInfo() throw() {
}


void TrustedInfo::__set_address(const Address& val) {
  this->address = val;
}

void TrustedInfo::__set_timesWriter(const int32_t val) {
  this->timesWriter = val;
}

void TrustedInfo::__set_timesTrusted(const int32_t val) {
  this->timesTrusted = val;
}

void TrustedInfo::__set_feeCollected(const Amount& val) {
  this->feeCollected = val;
}
std::ostream& operator<<(std::ostream& out, const TrustedInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TrustedInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->address);
          this->__isset.address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timesWriter);
          this->__isset.timesWriter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timesTrusted);
          this->__isset.timesTrusted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->feeCollected.read(iprot);
          this->__isset.feeCollected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TrustedInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TrustedInfo");

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->address);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timesWriter", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->timesWriter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timesTrusted", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->timesTrusted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("feeCollected", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->feeCollected.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TrustedInfo &a, TrustedInfo &b) {
  using ::std::swap;
  swap(a.address, b.address);
  swap(a.timesWriter, b.timesWriter);
  swap(a.timesTrusted, b.timesTrusted);
  swap(a.feeCollected, b.feeCollected);
  swap(a.__isset, b.__isset);
}

TrustedInfo::TrustedInfo(const TrustedInfo& other369) {
  address = other369.address;
  timesWriter = other369.timesWriter;
  timesTrusted = other369.timesTrusted;
  feeCollected = other369.feeCollected;
  __isset = other369.__isset;
}
TrustedInfo::TrustedInfo( TrustedInfo&& other370) {
  address = std::move(other370.address);
  timesWriter = std::move(other370.timesWriter);
  timesTrusted = std::move(other370.timesTrusted);
  feeCollected = std::move(other370.feeCollected);
  __isset = std::move(other370.__isset);
}
TrustedInfo& TrustedInfo::operator=(const TrustedInfo& other371) {
  address = other371.address;
  timesWriter = other371.timesWriter;
  timesTrusted = other371.timesTrusted;
  feeCollected = other371.feeCollected;
  __isset = other371.__isset;
  return *this;
}
TrustedInfo& TrustedInfo::operator=(TrustedInfo&& other372) {
  address = std::move(other372.address);
  timesWriter = std::move(other372.timesWriter);
  timesTrusted = std::move(other372.timesTrusted);
  feeCollected = std::move(other372.feeCollected);
  __isset = std::move(other372.__isset);
  return *this;
}
void TrustedInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TrustedInfo(";
  out << "address=" << to_string(address);
  out << ", " << "timesWriter=" << to_string(timesWriter);
  out << ", " << "timesTrusted=" << to_string(timesTrusted);
  out << ", " << "feeCollected=" << to_string(feeCollected);
  out << ")";
}


TrustedGetResult::~TrustedGetResult() throw() {
}


void TrustedGetResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void TrustedGetResult::__set_pages(const int32_t val) {
  this->pages = val;
}

void TrustedGetResult::__set_writers(const std::vector<TrustedInfo> & val) {
  this->writers = val;
}
std::ostream& operator<<(std::ostream& out, const TrustedGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TrustedGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pages);
          this->__isset.pages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->writers.clear();
            uint32_t _size373;
            ::apache::thrift::protocol::TType _etype376;
            xfer += iprot->readListBegin(_etype376, _size373);
            this->writers.resize(_size373);
            uint32_t _i377;
            for (_i377 = 0; _i377 < _size373; ++_i377)
            {
              xfer += this->writers[_i377].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.writers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TrustedGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TrustedGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pages", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->pages);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writers", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->writers.size()));
    std::vector<TrustedInfo> ::const_iterator _iter378;
    for (_iter378 = this->writers.begin(); _iter378 != this->writers.end(); ++_iter378)
    {
      xfer += (*_iter378).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TrustedGetResult &a, TrustedGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.pages, b.pages);
  swap(a.writers, b.writers);
  swap(a.__isset, b.__isset);
}

TrustedGetResult::TrustedGetResult(const TrustedGetResult& other379) {
  status = other379.status;
  pages = other379.pages;
  writers = other379.writers;
  __isset = other379.__isset;
}
TrustedGetResult::TrustedGetResult( TrustedGetResult&& other380) {
  status = std::move(other380.status);
  pages = std::move(other380.pages);
  writers = std::move(other380.writers);
  __isset = std::move(other380.__isset);
}
TrustedGetResult& TrustedGetResult::operator=(const TrustedGetResult& other381) {
  status = other381.status;
  pages = other381.pages;
  writers = other381.writers;
  __isset = other381.__isset;
  return *this;
}
TrustedGetResult& TrustedGetResult::operator=(TrustedGetResult&& other382) {
  status = std::move(other382.status);
  pages = std::move(other382.pages);
  writers = std::move(other382.writers);
  __isset = std::move(other382.__isset);
  return *this;
}
void TrustedGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TrustedGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "pages=" << to_string(pages);
  out << ", " << "writers=" << to_string(writers);
  out << ")";
}


SyncStateResult::~SyncStateResult() throw() {
}


void SyncStateResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void SyncStateResult::__set_currRound(const int64_t val) {
  this->currRound = val;
}

void SyncStateResult::__set_lastBlock(const int64_t val) {
  this->lastBlock = val;
}
std::ostream& operator<<(std::ostream& out, const SyncStateResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SyncStateResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->currRound);
          this->__isset.currRound = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastBlock);
          this->__isset.lastBlock = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SyncStateResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SyncStateResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currRound", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->currRound);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastBlock", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->lastBlock);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SyncStateResult &a, SyncStateResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.currRound, b.currRound);
  swap(a.lastBlock, b.lastBlock);
  swap(a.__isset, b.__isset);
}

SyncStateResult::SyncStateResult(const SyncStateResult& other383) {
  status = other383.status;
  currRound = other383.currRound;
  lastBlock = other383.lastBlock;
  __isset = other383.__isset;
}
SyncStateResult::SyncStateResult( SyncStateResult&& other384) {
  status = std::move(other384.status);
  currRound = std::move(other384.currRound);
  lastBlock = std::move(other384.lastBlock);
  __isset = std::move(other384.__isset);
}
SyncStateResult& SyncStateResult::operator=(const SyncStateResult& other385) {
  status = other385.status;
  currRound = other385.currRound;
  lastBlock = other385.lastBlock;
  __isset = other385.__isset;
  return *this;
}
SyncStateResult& SyncStateResult::operator=(SyncStateResult&& other386) {
  status = std::move(other386.status);
  currRound = std::move(other386.currRound);
  lastBlock = std::move(other386.lastBlock);
  __isset = std::move(other386.__isset);
  return *this;
}
void SyncStateResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SyncStateResult(";
  out << "status=" << to_string(status);
  out << ", " << "currRound=" << to_string(currRound);
  out << ", " << "lastBlock=" << to_string(lastBlock);
  out << ")";
}


GetSeedResult::~GetSeedResult() throw() {
}


void GetSeedResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void GetSeedResult::__set_seed(const std::string& val) {
  this->seed = val;
}
std::ostream& operator<<(std::ostream& out, const GetSeedResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetSeedResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->seed);
          this->__isset.seed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetSeedResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetSeedResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("seed", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->seed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetSeedResult &a, GetSeedResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.seed, b.seed);
  swap(a.__isset, b.__isset);
}

GetSeedResult::GetSeedResult(const GetSeedResult& other387) {
  status = other387.status;
  seed = other387.seed;
  __isset = other387.__isset;
}
GetSeedResult::GetSeedResult( GetSeedResult&& other388) {
  status = std::move(other388.status);
  seed = std::move(other388.seed);
  __isset = std::move(other388.__isset);
}
GetSeedResult& GetSeedResult::operator=(const GetSeedResult& other389) {
  status = other389.status;
  seed = other389.seed;
  __isset = other389.__isset;
  return *this;
}
GetSeedResult& GetSeedResult::operator=(GetSeedResult&& other390) {
  status = std::move(other390.status);
  seed = std::move(other390.seed);
  __isset = std::move(other390.__isset);
  return *this;
}
void GetSeedResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetSeedResult(";
  out << "status=" << to_string(status);
  out << ", " << "seed=" << to_string(seed);
  out << ")";
}


GetSmartCodeResult::~GetSmartCodeResult() throw() {
}


void GetSmartCodeResult::__set_status(const  ::general::APIResponse& val) {
  this->status = val;
}

void GetSmartCodeResult::__set_byteCodeObjects(const std::vector< ::general::ByteCodeObject> & val) {
  this->byteCodeObjects = val;
}

void GetSmartCodeResult::__set_contractState(const std::string& val) {
  this->contractState = val;
}
std::ostream& operator<<(std::ostream& out, const GetSmartCodeResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetSmartCodeResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->byteCodeObjects.clear();
            uint32_t _size391;
            ::apache::thrift::protocol::TType _etype394;
            xfer += iprot->readListBegin(_etype394, _size391);
            this->byteCodeObjects.resize(_size391);
            uint32_t _i395;
            for (_i395 = 0; _i395 < _size391; ++_i395)
            {
              xfer += this->byteCodeObjects[_i395].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.byteCodeObjects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->contractState);
          this->__isset.contractState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetSmartCodeResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetSmartCodeResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteCodeObjects", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->byteCodeObjects.size()));
    std::vector< ::general::ByteCodeObject> ::const_iterator _iter396;
    for (_iter396 = this->byteCodeObjects.begin(); _iter396 != this->byteCodeObjects.end(); ++_iter396)
    {
      xfer += (*_iter396).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contractState", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->contractState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetSmartCodeResult &a, GetSmartCodeResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.byteCodeObjects, b.byteCodeObjects);
  swap(a.contractState, b.contractState);
  swap(a.__isset, b.__isset);
}

GetSmartCodeResult::GetSmartCodeResult(const GetSmartCodeResult& other397) {
  status = other397.status;
  byteCodeObjects = other397.byteCodeObjects;
  contractState = other397.contractState;
  __isset = other397.__isset;
}
GetSmartCodeResult::GetSmartCodeResult( GetSmartCodeResult&& other398) {
  status = std::move(other398.status);
  byteCodeObjects = std::move(other398.byteCodeObjects);
  contractState = std::move(other398.contractState);
  __isset = std::move(other398.__isset);
}
GetSmartCodeResult& GetSmartCodeResult::operator=(const GetSmartCodeResult& other399) {
  status = other399.status;
  byteCodeObjects = other399.byteCodeObjects;
  contractState = other399.contractState;
  __isset = other399.__isset;
  return *this;
}
GetSmartCodeResult& GetSmartCodeResult::operator=(GetSmartCodeResult&& other400) {
  status = std::move(other400.status);
  byteCodeObjects = std::move(other400.byteCodeObjects);
  contractState = std::move(other400.contractState);
  __isset = std::move(other400.__isset);
  return *this;
}
void GetSmartCodeResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetSmartCodeResult(";
  out << "status=" << to_string(status);
  out << ", " << "byteCodeObjects=" << to_string(byteCodeObjects);
  out << ", " << "contractState=" << to_string(contractState);
  out << ")";
}

} // namespace
