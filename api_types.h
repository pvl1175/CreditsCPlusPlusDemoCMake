/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef api_TYPES_H
#define api_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>
#include "general_types.h"


namespace api {

enum TransactionType {
  TT_Normal = 0,
  TT_SmartDeploy = 1,
  TT_SmartExecute = 2,
  TT_SmartState = 3
};

extern const std::map<int, const char*> _TransactionType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TransactionType val);

enum SmartOperationState {
  SOS_Pending = 0,
  SOS_Success = 1,
  SOS_Failed = 2
};

extern const std::map<int, const char*> _SmartOperationState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SmartOperationState val);

enum TransactionState {
  INVALID = 0,
  VALID = 1,
  INPROGRESS = 2
};

extern const std::map<int, const char*> _TransactionState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TransactionState val);

enum TokenStandart {
  NotAToken = 0,
  CreditsBasic = 1,
  CreditsExtended = 2
};

extern const std::map<int, const char*> _TokenStandart_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TokenStandart val);

enum TokensListSortField {
  TL_Code = 0,
  TL_Name = 1,
  TL_Address = 2,
  TL_TotalSupply = 3,
  TL_HoldersCount = 4,
  TL_TransfersCount = 5,
  TL_TransactionsCount = 6
};

extern const std::map<int, const char*> _TokensListSortField_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TokensListSortField val);

enum TokenHoldersSortField {
  TH_Balance = 0,
  TH_TransfersCount = 1
};

extern const std::map<int, const char*> _TokenHoldersSortField_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TokenHoldersSortField val);

typedef int8_t Currency;

typedef std::string Address;

typedef int64_t Time;

typedef std::string TokenCode;

typedef std::string TokenAmount;

typedef std::map<Currency, class Amount>  Balance;

typedef std::map<Currency, class CumulativeAmount>  Total;

typedef int64_t TransactionInnerId;

typedef std::string PoolHash;

typedef int64_t PoolNumber;

typedef int32_t WalletId;

typedef int32_t Count;

typedef std::vector<class PeriodStats>  StatsPerPeriod;

typedef std::string NodeHash;

typedef int64_t AccessID;

class Amount;

class AmountCommission;

class CumulativeAmount;

class SmartContractDeploy;

class SmartContract;

class SmartContractInvocation;

class TransactionId;

class TokenDeployTransInfo;

class TokenTransferTransInfo;

class SmartDeployTransInfo;

class SmartExecutionTransInfo;

class SmartStateTransInfo;

class SmartTransInfo;

class Transaction;

class SealedTransaction;

class Pool;

class WalletData;

class PeriodStats;

class WalletDataGetResult;

class WalletIdGetResult;

class WalletTransactionsCountGetResult;

class WalletBalanceGetResult;

class TransactionGetResult;

class TransactionsGetResult;

class TransactionFlowResult;

class PoolListGetResult;

class PoolInfoGetResult;

class PoolTransactionsGetResult;

class StatsGetResult;

class SmartContractGetResult;

class SmartContractAddressesListGetResult;

class SmartContractsListGetResult;

class TransactionsStateGetResult;

class SmartMethodParamsGetResult;

class ContractAllMethodsGetResult;

class SmartContractMethodArgument;

class SmartContractMethod;

class SmartContractDataResult;

class SmartContractCompileResult;

class TokenInfo;

class TokenTransaction;

class TokenHolder;

class TokenBalance;

class TokenBalancesResult;

class TokenTransfer;

class TokenTransfersResult;

class TokenTransactionsResult;

class TokenInfoResult;

class TokenHoldersResult;

class TokensListResult;

class WalletInfo;

class WalletsGetResult;

class TrustedInfo;

class TrustedGetResult;

class SyncStateResult;

class GetSeedResult;

class GetSmartCodeResult;


class Amount : public virtual ::apache::thrift::TBase {
 public:

  Amount(const Amount&);
  Amount(Amount&&);
  Amount& operator=(const Amount&);
  Amount& operator=(Amount&&);
  Amount() : integral(0), fraction(0LL) {
  }

  virtual ~Amount() throw();
  int32_t integral;
  int64_t fraction;

  void __set_integral(const int32_t val);

  void __set_fraction(const int64_t val);

  bool operator == (const Amount & rhs) const
  {
    if (!(integral == rhs.integral))
      return false;
    if (!(fraction == rhs.fraction))
      return false;
    return true;
  }
  bool operator != (const Amount &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Amount & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Amount &a, Amount &b);

std::ostream& operator<<(std::ostream& out, const Amount& obj);


class AmountCommission : public virtual ::apache::thrift::TBase {
 public:

  AmountCommission(const AmountCommission&);
  AmountCommission(AmountCommission&&);
  AmountCommission& operator=(const AmountCommission&);
  AmountCommission& operator=(AmountCommission&&);
  AmountCommission() : commission(0) {
  }

  virtual ~AmountCommission() throw();
  int16_t commission;

  void __set_commission(const int16_t val);

  bool operator == (const AmountCommission & rhs) const
  {
    if (!(commission == rhs.commission))
      return false;
    return true;
  }
  bool operator != (const AmountCommission &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AmountCommission & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AmountCommission &a, AmountCommission &b);

std::ostream& operator<<(std::ostream& out, const AmountCommission& obj);


class CumulativeAmount : public virtual ::apache::thrift::TBase {
 public:

  CumulativeAmount(const CumulativeAmount&);
  CumulativeAmount(CumulativeAmount&&);
  CumulativeAmount& operator=(const CumulativeAmount&);
  CumulativeAmount& operator=(CumulativeAmount&&);
  CumulativeAmount() : integral(0LL), fraction(0LL) {
  }

  virtual ~CumulativeAmount() throw();
  int64_t integral;
  int64_t fraction;

  void __set_integral(const int64_t val);

  void __set_fraction(const int64_t val);

  bool operator == (const CumulativeAmount & rhs) const
  {
    if (!(integral == rhs.integral))
      return false;
    if (!(fraction == rhs.fraction))
      return false;
    return true;
  }
  bool operator != (const CumulativeAmount &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CumulativeAmount & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CumulativeAmount &a, CumulativeAmount &b);

std::ostream& operator<<(std::ostream& out, const CumulativeAmount& obj);

typedef struct _SmartContractDeploy__isset {
  _SmartContractDeploy__isset() : sourceCode(false), byteCodeObjects(false), hashState(false), tokenStandart(false) {}
  bool sourceCode :1;
  bool byteCodeObjects :1;
  bool hashState :1;
  bool tokenStandart :1;
} _SmartContractDeploy__isset;

class SmartContractDeploy : public virtual ::apache::thrift::TBase {
 public:

  SmartContractDeploy(const SmartContractDeploy&);
  SmartContractDeploy(SmartContractDeploy&&);
  SmartContractDeploy& operator=(const SmartContractDeploy&);
  SmartContractDeploy& operator=(SmartContractDeploy&&);
  SmartContractDeploy() : sourceCode(), hashState(), tokenStandart((TokenStandart)0) {
  }

  virtual ~SmartContractDeploy() throw();
  std::string sourceCode;
  std::vector< ::general::ByteCodeObject>  byteCodeObjects;
  std::string hashState;
  TokenStandart tokenStandart;

  _SmartContractDeploy__isset __isset;

  void __set_sourceCode(const std::string& val);

  void __set_byteCodeObjects(const std::vector< ::general::ByteCodeObject> & val);

  void __set_hashState(const std::string& val);

  void __set_tokenStandart(const TokenStandart val);

  bool operator == (const SmartContractDeploy & rhs) const
  {
    if (!(sourceCode == rhs.sourceCode))
      return false;
    if (!(byteCodeObjects == rhs.byteCodeObjects))
      return false;
    if (!(hashState == rhs.hashState))
      return false;
    if (!(tokenStandart == rhs.tokenStandart))
      return false;
    return true;
  }
  bool operator != (const SmartContractDeploy &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartContractDeploy & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartContractDeploy &a, SmartContractDeploy &b);

std::ostream& operator<<(std::ostream& out, const SmartContractDeploy& obj);

typedef struct _SmartContract__isset {
  _SmartContract__isset() : deployer(false), smartContractDeploy(false), objectState(false), createTime(false), transactionsCount(false) {}
  bool deployer :1;
  bool smartContractDeploy :1;
  bool objectState :1;
  bool createTime :1;
  bool transactionsCount :1;
} _SmartContract__isset;

class SmartContract : public virtual ::apache::thrift::TBase {
 public:

  SmartContract(const SmartContract&);
  SmartContract(SmartContract&&);
  SmartContract& operator=(const SmartContract&);
  SmartContract& operator=(SmartContract&&);
  SmartContract() : address(), deployer(), objectState(), createTime(0), transactionsCount(0) {
  }

  virtual ~SmartContract() throw();
  Address address;
  Address deployer;
  SmartContractDeploy smartContractDeploy;
  std::string objectState;
  Time createTime;
  int32_t transactionsCount;

  _SmartContract__isset __isset;

  void __set_address(const Address& val);

  void __set_deployer(const Address& val);

  void __set_smartContractDeploy(const SmartContractDeploy& val);

  void __set_objectState(const std::string& val);

  void __set_createTime(const Time val);

  void __set_transactionsCount(const int32_t val);

  bool operator == (const SmartContract & rhs) const
  {
    if (!(address == rhs.address))
      return false;
    if (!(deployer == rhs.deployer))
      return false;
    if (!(smartContractDeploy == rhs.smartContractDeploy))
      return false;
    if (!(objectState == rhs.objectState))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(transactionsCount == rhs.transactionsCount))
      return false;
    return true;
  }
  bool operator != (const SmartContract &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartContract & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartContract &a, SmartContract &b);

std::ostream& operator<<(std::ostream& out, const SmartContract& obj);

typedef struct _SmartContractInvocation__isset {
  _SmartContractInvocation__isset() : method(false), params(false), forgetNewState(false), smartContractDeploy(false) {}
  bool method :1;
  bool params :1;
  bool forgetNewState :1;
  bool smartContractDeploy :1;
} _SmartContractInvocation__isset;

class SmartContractInvocation : public virtual ::apache::thrift::TBase {
 public:

  SmartContractInvocation(const SmartContractInvocation&);
  SmartContractInvocation(SmartContractInvocation&&);
  SmartContractInvocation& operator=(const SmartContractInvocation&);
  SmartContractInvocation& operator=(SmartContractInvocation&&);
  SmartContractInvocation() : method(), forgetNewState(0) {
  }

  virtual ~SmartContractInvocation() throw();
  std::string method;
  std::vector< ::general::Variant>  params;
  bool forgetNewState;
  SmartContractDeploy smartContractDeploy;

  _SmartContractInvocation__isset __isset;

  void __set_method(const std::string& val);

  void __set_params(const std::vector< ::general::Variant> & val);

  void __set_forgetNewState(const bool val);

  void __set_smartContractDeploy(const SmartContractDeploy& val);

  bool operator == (const SmartContractInvocation & rhs) const
  {
    if (!(method == rhs.method))
      return false;
    if (!(params == rhs.params))
      return false;
    if (!(forgetNewState == rhs.forgetNewState))
      return false;
    if (__isset.smartContractDeploy != rhs.__isset.smartContractDeploy)
      return false;
    else if (__isset.smartContractDeploy && !(smartContractDeploy == rhs.smartContractDeploy))
      return false;
    return true;
  }
  bool operator != (const SmartContractInvocation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartContractInvocation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartContractInvocation &a, SmartContractInvocation &b);

std::ostream& operator<<(std::ostream& out, const SmartContractInvocation& obj);

typedef struct _TransactionId__isset {
  _TransactionId__isset() : poolHash(false), index(false) {}
  bool poolHash :1;
  bool index :1;
} _TransactionId__isset;

class TransactionId : public virtual ::apache::thrift::TBase {
 public:

  TransactionId(const TransactionId&);
  TransactionId(TransactionId&&);
  TransactionId& operator=(const TransactionId&);
  TransactionId& operator=(TransactionId&&);
  TransactionId() : poolHash(), index(0) {
  }

  virtual ~TransactionId() throw();
  PoolHash poolHash;
  int32_t index;

  _TransactionId__isset __isset;

  void __set_poolHash(const PoolHash& val);

  void __set_index(const int32_t val);

  bool operator == (const TransactionId & rhs) const
  {
    if (!(poolHash == rhs.poolHash))
      return false;
    if (!(index == rhs.index))
      return false;
    return true;
  }
  bool operator != (const TransactionId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TransactionId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TransactionId &a, TransactionId &b);

std::ostream& operator<<(std::ostream& out, const TransactionId& obj);

typedef struct _TokenDeployTransInfo__isset {
  _TokenDeployTransInfo__isset() : name(false), code(false), standart(false), state(false), stateTransaction(false) {}
  bool name :1;
  bool code :1;
  bool standart :1;
  bool state :1;
  bool stateTransaction :1;
} _TokenDeployTransInfo__isset;

class TokenDeployTransInfo : public virtual ::apache::thrift::TBase {
 public:

  TokenDeployTransInfo(const TokenDeployTransInfo&);
  TokenDeployTransInfo(TokenDeployTransInfo&&);
  TokenDeployTransInfo& operator=(const TokenDeployTransInfo&);
  TokenDeployTransInfo& operator=(TokenDeployTransInfo&&);
  TokenDeployTransInfo() : name(), code(), standart((TokenStandart)0), state((SmartOperationState)0) {
  }

  virtual ~TokenDeployTransInfo() throw();
  std::string name;
  TokenCode code;
  TokenStandart standart;
  SmartOperationState state;
  TransactionId stateTransaction;

  _TokenDeployTransInfo__isset __isset;

  void __set_name(const std::string& val);

  void __set_code(const TokenCode& val);

  void __set_standart(const TokenStandart val);

  void __set_state(const SmartOperationState val);

  void __set_stateTransaction(const TransactionId& val);

  bool operator == (const TokenDeployTransInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(code == rhs.code))
      return false;
    if (!(standart == rhs.standart))
      return false;
    if (!(state == rhs.state))
      return false;
    if (__isset.stateTransaction != rhs.__isset.stateTransaction)
      return false;
    else if (__isset.stateTransaction && !(stateTransaction == rhs.stateTransaction))
      return false;
    return true;
  }
  bool operator != (const TokenDeployTransInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenDeployTransInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TokenDeployTransInfo &a, TokenDeployTransInfo &b);

std::ostream& operator<<(std::ostream& out, const TokenDeployTransInfo& obj);

typedef struct _TokenTransferTransInfo__isset {
  _TokenTransferTransInfo__isset() : code(false), sender(false), receiver(false), amount(false), state(false), stateTransaction(false), transferSuccess(false) {}
  bool code :1;
  bool sender :1;
  bool receiver :1;
  bool amount :1;
  bool state :1;
  bool stateTransaction :1;
  bool transferSuccess :1;
} _TokenTransferTransInfo__isset;

class TokenTransferTransInfo : public virtual ::apache::thrift::TBase {
 public:

  TokenTransferTransInfo(const TokenTransferTransInfo&);
  TokenTransferTransInfo(TokenTransferTransInfo&&);
  TokenTransferTransInfo& operator=(const TokenTransferTransInfo&);
  TokenTransferTransInfo& operator=(TokenTransferTransInfo&&);
  TokenTransferTransInfo() : code(), sender(), receiver(), amount(), state((SmartOperationState)0), transferSuccess(0) {
  }

  virtual ~TokenTransferTransInfo() throw();
  TokenCode code;
  Address sender;
  Address receiver;
  TokenAmount amount;
  SmartOperationState state;
  TransactionId stateTransaction;
  bool transferSuccess;

  _TokenTransferTransInfo__isset __isset;

  void __set_code(const TokenCode& val);

  void __set_sender(const Address& val);

  void __set_receiver(const Address& val);

  void __set_amount(const TokenAmount& val);

  void __set_state(const SmartOperationState val);

  void __set_stateTransaction(const TransactionId& val);

  void __set_transferSuccess(const bool val);

  bool operator == (const TokenTransferTransInfo & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (!(sender == rhs.sender))
      return false;
    if (!(receiver == rhs.receiver))
      return false;
    if (!(amount == rhs.amount))
      return false;
    if (!(state == rhs.state))
      return false;
    if (__isset.stateTransaction != rhs.__isset.stateTransaction)
      return false;
    else if (__isset.stateTransaction && !(stateTransaction == rhs.stateTransaction))
      return false;
    if (__isset.transferSuccess != rhs.__isset.transferSuccess)
      return false;
    else if (__isset.transferSuccess && !(transferSuccess == rhs.transferSuccess))
      return false;
    return true;
  }
  bool operator != (const TokenTransferTransInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenTransferTransInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TokenTransferTransInfo &a, TokenTransferTransInfo &b);

std::ostream& operator<<(std::ostream& out, const TokenTransferTransInfo& obj);

typedef struct _SmartDeployTransInfo__isset {
  _SmartDeployTransInfo__isset() : state(false), stateTransaction(false) {}
  bool state :1;
  bool stateTransaction :1;
} _SmartDeployTransInfo__isset;

class SmartDeployTransInfo : public virtual ::apache::thrift::TBase {
 public:

  SmartDeployTransInfo(const SmartDeployTransInfo&);
  SmartDeployTransInfo(SmartDeployTransInfo&&);
  SmartDeployTransInfo& operator=(const SmartDeployTransInfo&);
  SmartDeployTransInfo& operator=(SmartDeployTransInfo&&);
  SmartDeployTransInfo() : state((SmartOperationState)0) {
  }

  virtual ~SmartDeployTransInfo() throw();
  SmartOperationState state;
  TransactionId stateTransaction;

  _SmartDeployTransInfo__isset __isset;

  void __set_state(const SmartOperationState val);

  void __set_stateTransaction(const TransactionId& val);

  bool operator == (const SmartDeployTransInfo & rhs) const
  {
    if (!(state == rhs.state))
      return false;
    if (__isset.stateTransaction != rhs.__isset.stateTransaction)
      return false;
    else if (__isset.stateTransaction && !(stateTransaction == rhs.stateTransaction))
      return false;
    return true;
  }
  bool operator != (const SmartDeployTransInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartDeployTransInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartDeployTransInfo &a, SmartDeployTransInfo &b);

std::ostream& operator<<(std::ostream& out, const SmartDeployTransInfo& obj);

typedef struct _SmartExecutionTransInfo__isset {
  _SmartExecutionTransInfo__isset() : method(false), params(false), state(false), stateTransaction(false) {}
  bool method :1;
  bool params :1;
  bool state :1;
  bool stateTransaction :1;
} _SmartExecutionTransInfo__isset;

class SmartExecutionTransInfo : public virtual ::apache::thrift::TBase {
 public:

  SmartExecutionTransInfo(const SmartExecutionTransInfo&);
  SmartExecutionTransInfo(SmartExecutionTransInfo&&);
  SmartExecutionTransInfo& operator=(const SmartExecutionTransInfo&);
  SmartExecutionTransInfo& operator=(SmartExecutionTransInfo&&);
  SmartExecutionTransInfo() : method(), state((SmartOperationState)0) {
  }

  virtual ~SmartExecutionTransInfo() throw();
  std::string method;
  std::vector< ::general::Variant>  params;
  SmartOperationState state;
  TransactionId stateTransaction;

  _SmartExecutionTransInfo__isset __isset;

  void __set_method(const std::string& val);

  void __set_params(const std::vector< ::general::Variant> & val);

  void __set_state(const SmartOperationState val);

  void __set_stateTransaction(const TransactionId& val);

  bool operator == (const SmartExecutionTransInfo & rhs) const
  {
    if (!(method == rhs.method))
      return false;
    if (!(params == rhs.params))
      return false;
    if (!(state == rhs.state))
      return false;
    if (__isset.stateTransaction != rhs.__isset.stateTransaction)
      return false;
    else if (__isset.stateTransaction && !(stateTransaction == rhs.stateTransaction))
      return false;
    return true;
  }
  bool operator != (const SmartExecutionTransInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartExecutionTransInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartExecutionTransInfo &a, SmartExecutionTransInfo &b);

std::ostream& operator<<(std::ostream& out, const SmartExecutionTransInfo& obj);

typedef struct _SmartStateTransInfo__isset {
  _SmartStateTransInfo__isset() : success(false), executionFee(false), returnValue(false), startTransaction(false) {}
  bool success :1;
  bool executionFee :1;
  bool returnValue :1;
  bool startTransaction :1;
} _SmartStateTransInfo__isset;

class SmartStateTransInfo : public virtual ::apache::thrift::TBase {
 public:

  SmartStateTransInfo(const SmartStateTransInfo&);
  SmartStateTransInfo(SmartStateTransInfo&&);
  SmartStateTransInfo& operator=(const SmartStateTransInfo&);
  SmartStateTransInfo& operator=(SmartStateTransInfo&&);
  SmartStateTransInfo() : success(0) {
  }

  virtual ~SmartStateTransInfo() throw();
  bool success;
  Amount executionFee;
   ::general::Variant returnValue;
  TransactionId startTransaction;

  _SmartStateTransInfo__isset __isset;

  void __set_success(const bool val);

  void __set_executionFee(const Amount& val);

  void __set_returnValue(const  ::general::Variant& val);

  void __set_startTransaction(const TransactionId& val);

  bool operator == (const SmartStateTransInfo & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(executionFee == rhs.executionFee))
      return false;
    if (__isset.returnValue != rhs.__isset.returnValue)
      return false;
    else if (__isset.returnValue && !(returnValue == rhs.returnValue))
      return false;
    if (!(startTransaction == rhs.startTransaction))
      return false;
    return true;
  }
  bool operator != (const SmartStateTransInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartStateTransInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartStateTransInfo &a, SmartStateTransInfo &b);

std::ostream& operator<<(std::ostream& out, const SmartStateTransInfo& obj);

typedef struct _SmartTransInfo__isset {
  _SmartTransInfo__isset() : v_tokenDeploy(false), v_tokenTransfer(false), v_smartDeploy(false), v_smartExecution(false), v_smartState(false) {}
  bool v_tokenDeploy :1;
  bool v_tokenTransfer :1;
  bool v_smartDeploy :1;
  bool v_smartExecution :1;
  bool v_smartState :1;
} _SmartTransInfo__isset;

class SmartTransInfo : public virtual ::apache::thrift::TBase {
 public:

  SmartTransInfo(const SmartTransInfo&);
  SmartTransInfo(SmartTransInfo&&);
  SmartTransInfo& operator=(const SmartTransInfo&);
  SmartTransInfo& operator=(SmartTransInfo&&);
  SmartTransInfo() {
  }

  virtual ~SmartTransInfo() throw();
  TokenDeployTransInfo v_tokenDeploy;
  TokenTransferTransInfo v_tokenTransfer;
  SmartDeployTransInfo v_smartDeploy;
  SmartExecutionTransInfo v_smartExecution;
  SmartStateTransInfo v_smartState;

  _SmartTransInfo__isset __isset;

  void __set_v_tokenDeploy(const TokenDeployTransInfo& val);

  void __set_v_tokenTransfer(const TokenTransferTransInfo& val);

  void __set_v_smartDeploy(const SmartDeployTransInfo& val);

  void __set_v_smartExecution(const SmartExecutionTransInfo& val);

  void __set_v_smartState(const SmartStateTransInfo& val);

  bool operator == (const SmartTransInfo & rhs) const
  {
    if (__isset.v_tokenDeploy != rhs.__isset.v_tokenDeploy)
      return false;
    else if (__isset.v_tokenDeploy && !(v_tokenDeploy == rhs.v_tokenDeploy))
      return false;
    if (__isset.v_tokenTransfer != rhs.__isset.v_tokenTransfer)
      return false;
    else if (__isset.v_tokenTransfer && !(v_tokenTransfer == rhs.v_tokenTransfer))
      return false;
    if (__isset.v_smartDeploy != rhs.__isset.v_smartDeploy)
      return false;
    else if (__isset.v_smartDeploy && !(v_smartDeploy == rhs.v_smartDeploy))
      return false;
    if (__isset.v_smartExecution != rhs.__isset.v_smartExecution)
      return false;
    else if (__isset.v_smartExecution && !(v_smartExecution == rhs.v_smartExecution))
      return false;
    if (__isset.v_smartState != rhs.__isset.v_smartState)
      return false;
    else if (__isset.v_smartState && !(v_smartState == rhs.v_smartState))
      return false;
    return true;
  }
  bool operator != (const SmartTransInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartTransInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartTransInfo &a, SmartTransInfo &b);

std::ostream& operator<<(std::ostream& out, const SmartTransInfo& obj);

typedef struct _Transaction__isset {
  _Transaction__isset() : id(false), source(false), target(false), amount(false), balance(false), currency(false), signature(false), smartContract(false), fee(false), timeCreation(false), userFields(false), type(false), smartInfo(false) {}
  bool id :1;
  bool source :1;
  bool target :1;
  bool amount :1;
  bool balance :1;
  bool currency :1;
  bool signature :1;
  bool smartContract :1;
  bool fee :1;
  bool timeCreation :1;
  bool userFields :1;
  bool type :1;
  bool smartInfo :1;
} _Transaction__isset;

class Transaction : public virtual ::apache::thrift::TBase {
 public:

  Transaction(const Transaction&);
  Transaction(Transaction&&);
  Transaction& operator=(const Transaction&);
  Transaction& operator=(Transaction&&);
  Transaction() : id(0), source(), target(), currency(0), signature(), timeCreation(0), userFields(), type((TransactionType)0) {
  }

  virtual ~Transaction() throw();
  TransactionInnerId id;
  Address source;
  Address target;
  Amount amount;
  Amount balance;
  Currency currency;
  std::string signature;
  SmartContractInvocation smartContract;
  AmountCommission fee;
  Time timeCreation;
  std::string userFields;
  TransactionType type;
  SmartTransInfo smartInfo;

  _Transaction__isset __isset;

  void __set_id(const TransactionInnerId val);

  void __set_source(const Address& val);

  void __set_target(const Address& val);

  void __set_amount(const Amount& val);

  void __set_balance(const Amount& val);

  void __set_currency(const Currency val);

  void __set_signature(const std::string& val);

  void __set_smartContract(const SmartContractInvocation& val);

  void __set_fee(const AmountCommission& val);

  void __set_timeCreation(const Time val);

  void __set_userFields(const std::string& val);

  void __set_type(const TransactionType val);

  void __set_smartInfo(const SmartTransInfo& val);

  bool operator == (const Transaction & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(source == rhs.source))
      return false;
    if (!(target == rhs.target))
      return false;
    if (!(amount == rhs.amount))
      return false;
    if (!(balance == rhs.balance))
      return false;
    if (!(currency == rhs.currency))
      return false;
    if (!(signature == rhs.signature))
      return false;
    if (__isset.smartContract != rhs.__isset.smartContract)
      return false;
    else if (__isset.smartContract && !(smartContract == rhs.smartContract))
      return false;
    if (!(fee == rhs.fee))
      return false;
    if (!(timeCreation == rhs.timeCreation))
      return false;
    if (__isset.userFields != rhs.__isset.userFields)
      return false;
    else if (__isset.userFields && !(userFields == rhs.userFields))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.smartInfo != rhs.__isset.smartInfo)
      return false;
    else if (__isset.smartInfo && !(smartInfo == rhs.smartInfo))
      return false;
    return true;
  }
  bool operator != (const Transaction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Transaction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Transaction &a, Transaction &b);

std::ostream& operator<<(std::ostream& out, const Transaction& obj);

typedef struct _SealedTransaction__isset {
  _SealedTransaction__isset() : id(false), trxn(false) {}
  bool id :1;
  bool trxn :1;
} _SealedTransaction__isset;

class SealedTransaction : public virtual ::apache::thrift::TBase {
 public:

  SealedTransaction(const SealedTransaction&);
  SealedTransaction(SealedTransaction&&);
  SealedTransaction& operator=(const SealedTransaction&);
  SealedTransaction& operator=(SealedTransaction&&);
  SealedTransaction() {
  }

  virtual ~SealedTransaction() throw();
  TransactionId id;
  Transaction trxn;

  _SealedTransaction__isset __isset;

  void __set_id(const TransactionId& val);

  void __set_trxn(const Transaction& val);

  bool operator == (const SealedTransaction & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(trxn == rhs.trxn))
      return false;
    return true;
  }
  bool operator != (const SealedTransaction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SealedTransaction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SealedTransaction &a, SealedTransaction &b);

std::ostream& operator<<(std::ostream& out, const SealedTransaction& obj);

typedef struct _Pool__isset {
  _Pool__isset() : hash(false), prevHash(false), time(false), transactionsCount(false), poolNumber(false), writer(false), totalFee(false) {}
  bool hash :1;
  bool prevHash :1;
  bool time :1;
  bool transactionsCount :1;
  bool poolNumber :1;
  bool writer :1;
  bool totalFee :1;
} _Pool__isset;

class Pool : public virtual ::apache::thrift::TBase {
 public:

  Pool(const Pool&);
  Pool(Pool&&);
  Pool& operator=(const Pool&);
  Pool& operator=(Pool&&);
  Pool() : hash(), prevHash(), time(0), transactionsCount(0), poolNumber(0), writer() {
  }

  virtual ~Pool() throw();
  PoolHash hash;
  PoolHash prevHash;
  Time time;
  int32_t transactionsCount;
  PoolNumber poolNumber;
  Address writer;
  Amount totalFee;

  _Pool__isset __isset;

  void __set_hash(const PoolHash& val);

  void __set_prevHash(const PoolHash& val);

  void __set_time(const Time val);

  void __set_transactionsCount(const int32_t val);

  void __set_poolNumber(const PoolNumber val);

  void __set_writer(const Address& val);

  void __set_totalFee(const Amount& val);

  bool operator == (const Pool & rhs) const
  {
    if (!(hash == rhs.hash))
      return false;
    if (!(prevHash == rhs.prevHash))
      return false;
    if (!(time == rhs.time))
      return false;
    if (!(transactionsCount == rhs.transactionsCount))
      return false;
    if (!(poolNumber == rhs.poolNumber))
      return false;
    if (!(writer == rhs.writer))
      return false;
    if (!(totalFee == rhs.totalFee))
      return false;
    return true;
  }
  bool operator != (const Pool &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pool & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Pool &a, Pool &b);

std::ostream& operator<<(std::ostream& out, const Pool& obj);

typedef struct _WalletData__isset {
  _WalletData__isset() : walletId(false), balance(false), lastTransactionId(false) {}
  bool walletId :1;
  bool balance :1;
  bool lastTransactionId :1;
} _WalletData__isset;

class WalletData : public virtual ::apache::thrift::TBase {
 public:

  WalletData(const WalletData&);
  WalletData(WalletData&&);
  WalletData& operator=(const WalletData&);
  WalletData& operator=(WalletData&&);
  WalletData() : walletId(0), lastTransactionId(0) {
  }

  virtual ~WalletData() throw();
  WalletId walletId;
  Amount balance;
  TransactionInnerId lastTransactionId;

  _WalletData__isset __isset;

  void __set_walletId(const WalletId val);

  void __set_balance(const Amount& val);

  void __set_lastTransactionId(const TransactionInnerId val);

  bool operator == (const WalletData & rhs) const
  {
    if (!(walletId == rhs.walletId))
      return false;
    if (!(balance == rhs.balance))
      return false;
    if (!(lastTransactionId == rhs.lastTransactionId))
      return false;
    return true;
  }
  bool operator != (const WalletData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WalletData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WalletData &a, WalletData &b);

std::ostream& operator<<(std::ostream& out, const WalletData& obj);

typedef struct _PeriodStats__isset {
  _PeriodStats__isset() : periodDuration(false), poolsCount(false), transactionsCount(false), balancePerCurrency(false), smartContractsCount(false), transactionsSmartCount(false) {}
  bool periodDuration :1;
  bool poolsCount :1;
  bool transactionsCount :1;
  bool balancePerCurrency :1;
  bool smartContractsCount :1;
  bool transactionsSmartCount :1;
} _PeriodStats__isset;

class PeriodStats : public virtual ::apache::thrift::TBase {
 public:

  PeriodStats(const PeriodStats&);
  PeriodStats(PeriodStats&&);
  PeriodStats& operator=(const PeriodStats&);
  PeriodStats& operator=(PeriodStats&&);
  PeriodStats() : periodDuration(0), poolsCount(0), transactionsCount(0), smartContractsCount(0), transactionsSmartCount(0) {
  }

  virtual ~PeriodStats() throw();
  Time periodDuration;
  Count poolsCount;
  Count transactionsCount;
  Total balancePerCurrency;
  Count smartContractsCount;
  Count transactionsSmartCount;

  _PeriodStats__isset __isset;

  void __set_periodDuration(const Time val);

  void __set_poolsCount(const Count val);

  void __set_transactionsCount(const Count val);

  void __set_balancePerCurrency(const Total& val);

  void __set_smartContractsCount(const Count val);

  void __set_transactionsSmartCount(const Count val);

  bool operator == (const PeriodStats & rhs) const
  {
    if (!(periodDuration == rhs.periodDuration))
      return false;
    if (!(poolsCount == rhs.poolsCount))
      return false;
    if (!(transactionsCount == rhs.transactionsCount))
      return false;
    if (!(balancePerCurrency == rhs.balancePerCurrency))
      return false;
    if (!(smartContractsCount == rhs.smartContractsCount))
      return false;
    if (!(transactionsSmartCount == rhs.transactionsSmartCount))
      return false;
    return true;
  }
  bool operator != (const PeriodStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PeriodStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PeriodStats &a, PeriodStats &b);

std::ostream& operator<<(std::ostream& out, const PeriodStats& obj);

typedef struct _WalletDataGetResult__isset {
  _WalletDataGetResult__isset() : status(false), walletData(false) {}
  bool status :1;
  bool walletData :1;
} _WalletDataGetResult__isset;

class WalletDataGetResult : public virtual ::apache::thrift::TBase {
 public:

  WalletDataGetResult(const WalletDataGetResult&);
  WalletDataGetResult(WalletDataGetResult&&);
  WalletDataGetResult& operator=(const WalletDataGetResult&);
  WalletDataGetResult& operator=(WalletDataGetResult&&);
  WalletDataGetResult() {
  }

  virtual ~WalletDataGetResult() throw();
   ::general::APIResponse status;
  WalletData walletData;

  _WalletDataGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_walletData(const WalletData& val);

  bool operator == (const WalletDataGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(walletData == rhs.walletData))
      return false;
    return true;
  }
  bool operator != (const WalletDataGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WalletDataGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WalletDataGetResult &a, WalletDataGetResult &b);

std::ostream& operator<<(std::ostream& out, const WalletDataGetResult& obj);

typedef struct _WalletIdGetResult__isset {
  _WalletIdGetResult__isset() : status(false), walletId(false) {}
  bool status :1;
  bool walletId :1;
} _WalletIdGetResult__isset;

class WalletIdGetResult : public virtual ::apache::thrift::TBase {
 public:

  WalletIdGetResult(const WalletIdGetResult&);
  WalletIdGetResult(WalletIdGetResult&&);
  WalletIdGetResult& operator=(const WalletIdGetResult&);
  WalletIdGetResult& operator=(WalletIdGetResult&&);
  WalletIdGetResult() : walletId(0) {
  }

  virtual ~WalletIdGetResult() throw();
   ::general::APIResponse status;
  WalletId walletId;

  _WalletIdGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_walletId(const WalletId val);

  bool operator == (const WalletIdGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(walletId == rhs.walletId))
      return false;
    return true;
  }
  bool operator != (const WalletIdGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WalletIdGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WalletIdGetResult &a, WalletIdGetResult &b);

std::ostream& operator<<(std::ostream& out, const WalletIdGetResult& obj);

typedef struct _WalletTransactionsCountGetResult__isset {
  _WalletTransactionsCountGetResult__isset() : status(false), lastTransactionInnerId(false) {}
  bool status :1;
  bool lastTransactionInnerId :1;
} _WalletTransactionsCountGetResult__isset;

class WalletTransactionsCountGetResult : public virtual ::apache::thrift::TBase {
 public:

  WalletTransactionsCountGetResult(const WalletTransactionsCountGetResult&);
  WalletTransactionsCountGetResult(WalletTransactionsCountGetResult&&);
  WalletTransactionsCountGetResult& operator=(const WalletTransactionsCountGetResult&);
  WalletTransactionsCountGetResult& operator=(WalletTransactionsCountGetResult&&);
  WalletTransactionsCountGetResult() : lastTransactionInnerId(0) {
  }

  virtual ~WalletTransactionsCountGetResult() throw();
   ::general::APIResponse status;
  TransactionInnerId lastTransactionInnerId;

  _WalletTransactionsCountGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_lastTransactionInnerId(const TransactionInnerId val);

  bool operator == (const WalletTransactionsCountGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(lastTransactionInnerId == rhs.lastTransactionInnerId))
      return false;
    return true;
  }
  bool operator != (const WalletTransactionsCountGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WalletTransactionsCountGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WalletTransactionsCountGetResult &a, WalletTransactionsCountGetResult &b);

std::ostream& operator<<(std::ostream& out, const WalletTransactionsCountGetResult& obj);

typedef struct _WalletBalanceGetResult__isset {
  _WalletBalanceGetResult__isset() : status(false), balance(false) {}
  bool status :1;
  bool balance :1;
} _WalletBalanceGetResult__isset;

class WalletBalanceGetResult : public virtual ::apache::thrift::TBase {
 public:

  WalletBalanceGetResult(const WalletBalanceGetResult&);
  WalletBalanceGetResult(WalletBalanceGetResult&&);
  WalletBalanceGetResult& operator=(const WalletBalanceGetResult&);
  WalletBalanceGetResult& operator=(WalletBalanceGetResult&&);
  WalletBalanceGetResult() {
  }

  virtual ~WalletBalanceGetResult() throw();
   ::general::APIResponse status;
  Amount balance;

  _WalletBalanceGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_balance(const Amount& val);

  bool operator == (const WalletBalanceGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(balance == rhs.balance))
      return false;
    return true;
  }
  bool operator != (const WalletBalanceGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WalletBalanceGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WalletBalanceGetResult &a, WalletBalanceGetResult &b);

std::ostream& operator<<(std::ostream& out, const WalletBalanceGetResult& obj);

typedef struct _TransactionGetResult__isset {
  _TransactionGetResult__isset() : status(false), found(false), state(false), roundNum(false), transaction(false) {}
  bool status :1;
  bool found :1;
  bool state :1;
  bool roundNum :1;
  bool transaction :1;
} _TransactionGetResult__isset;

class TransactionGetResult : public virtual ::apache::thrift::TBase {
 public:

  TransactionGetResult(const TransactionGetResult&);
  TransactionGetResult(TransactionGetResult&&);
  TransactionGetResult& operator=(const TransactionGetResult&);
  TransactionGetResult& operator=(TransactionGetResult&&);
  TransactionGetResult() : found(0), state((TransactionState)0), roundNum(0) {
  }

  virtual ~TransactionGetResult() throw();
   ::general::APIResponse status;
  bool found;
  TransactionState state;
  int32_t roundNum;
  SealedTransaction transaction;

  _TransactionGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_found(const bool val);

  void __set_state(const TransactionState val);

  void __set_roundNum(const int32_t val);

  void __set_transaction(const SealedTransaction& val);

  bool operator == (const TransactionGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(found == rhs.found))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(roundNum == rhs.roundNum))
      return false;
    if (!(transaction == rhs.transaction))
      return false;
    return true;
  }
  bool operator != (const TransactionGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TransactionGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TransactionGetResult &a, TransactionGetResult &b);

std::ostream& operator<<(std::ostream& out, const TransactionGetResult& obj);

typedef struct _TransactionsGetResult__isset {
  _TransactionsGetResult__isset() : status(false), result(false), total_trxns_count(false), transactions(false) {}
  bool status :1;
  bool result :1;
  bool total_trxns_count :1;
  bool transactions :1;
} _TransactionsGetResult__isset;

class TransactionsGetResult : public virtual ::apache::thrift::TBase {
 public:

  TransactionsGetResult(const TransactionsGetResult&);
  TransactionsGetResult(TransactionsGetResult&&);
  TransactionsGetResult& operator=(const TransactionsGetResult&);
  TransactionsGetResult& operator=(TransactionsGetResult&&);
  TransactionsGetResult() : result(0), total_trxns_count(0) {
  }

  virtual ~TransactionsGetResult() throw();
   ::general::APIResponse status;
  bool result;
  int32_t total_trxns_count;
  std::vector<SealedTransaction>  transactions;

  _TransactionsGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_result(const bool val);

  void __set_total_trxns_count(const int32_t val);

  void __set_transactions(const std::vector<SealedTransaction> & val);

  bool operator == (const TransactionsGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(result == rhs.result))
      return false;
    if (!(total_trxns_count == rhs.total_trxns_count))
      return false;
    if (!(transactions == rhs.transactions))
      return false;
    return true;
  }
  bool operator != (const TransactionsGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TransactionsGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TransactionsGetResult &a, TransactionsGetResult &b);

std::ostream& operator<<(std::ostream& out, const TransactionsGetResult& obj);

typedef struct _TransactionFlowResult__isset {
  _TransactionFlowResult__isset() : status(false), smart_contract_result(false), roundNum(false) {}
  bool status :1;
  bool smart_contract_result :1;
  bool roundNum :1;
} _TransactionFlowResult__isset;

class TransactionFlowResult : public virtual ::apache::thrift::TBase {
 public:

  TransactionFlowResult(const TransactionFlowResult&);
  TransactionFlowResult(TransactionFlowResult&&);
  TransactionFlowResult& operator=(const TransactionFlowResult&);
  TransactionFlowResult& operator=(TransactionFlowResult&&);
  TransactionFlowResult() : roundNum(0) {
  }

  virtual ~TransactionFlowResult() throw();
   ::general::APIResponse status;
   ::general::Variant smart_contract_result;
  int32_t roundNum;

  _TransactionFlowResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_smart_contract_result(const  ::general::Variant& val);

  void __set_roundNum(const int32_t val);

  bool operator == (const TransactionFlowResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.smart_contract_result != rhs.__isset.smart_contract_result)
      return false;
    else if (__isset.smart_contract_result && !(smart_contract_result == rhs.smart_contract_result))
      return false;
    if (!(roundNum == rhs.roundNum))
      return false;
    return true;
  }
  bool operator != (const TransactionFlowResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TransactionFlowResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TransactionFlowResult &a, TransactionFlowResult &b);

std::ostream& operator<<(std::ostream& out, const TransactionFlowResult& obj);

typedef struct _PoolListGetResult__isset {
  _PoolListGetResult__isset() : status(false), result(false), count(false), pools(false) {}
  bool status :1;
  bool result :1;
  bool count :1;
  bool pools :1;
} _PoolListGetResult__isset;

class PoolListGetResult : public virtual ::apache::thrift::TBase {
 public:

  PoolListGetResult(const PoolListGetResult&);
  PoolListGetResult(PoolListGetResult&&);
  PoolListGetResult& operator=(const PoolListGetResult&);
  PoolListGetResult& operator=(PoolListGetResult&&);
  PoolListGetResult() : result(0), count(0) {
  }

  virtual ~PoolListGetResult() throw();
   ::general::APIResponse status;
  bool result;
  int32_t count;
  std::vector<Pool>  pools;

  _PoolListGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_result(const bool val);

  void __set_count(const int32_t val);

  void __set_pools(const std::vector<Pool> & val);

  bool operator == (const PoolListGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(result == rhs.result))
      return false;
    if (!(count == rhs.count))
      return false;
    if (!(pools == rhs.pools))
      return false;
    return true;
  }
  bool operator != (const PoolListGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PoolListGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PoolListGetResult &a, PoolListGetResult &b);

std::ostream& operator<<(std::ostream& out, const PoolListGetResult& obj);

typedef struct _PoolInfoGetResult__isset {
  _PoolInfoGetResult__isset() : status(false), isFound(false), pool(false) {}
  bool status :1;
  bool isFound :1;
  bool pool :1;
} _PoolInfoGetResult__isset;

class PoolInfoGetResult : public virtual ::apache::thrift::TBase {
 public:

  PoolInfoGetResult(const PoolInfoGetResult&);
  PoolInfoGetResult(PoolInfoGetResult&&);
  PoolInfoGetResult& operator=(const PoolInfoGetResult&);
  PoolInfoGetResult& operator=(PoolInfoGetResult&&);
  PoolInfoGetResult() : isFound(0) {
  }

  virtual ~PoolInfoGetResult() throw();
   ::general::APIResponse status;
  bool isFound;
  Pool pool;

  _PoolInfoGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_isFound(const bool val);

  void __set_pool(const Pool& val);

  bool operator == (const PoolInfoGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(isFound == rhs.isFound))
      return false;
    if (!(pool == rhs.pool))
      return false;
    return true;
  }
  bool operator != (const PoolInfoGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PoolInfoGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PoolInfoGetResult &a, PoolInfoGetResult &b);

std::ostream& operator<<(std::ostream& out, const PoolInfoGetResult& obj);

typedef struct _PoolTransactionsGetResult__isset {
  _PoolTransactionsGetResult__isset() : status(false), transactions(false) {}
  bool status :1;
  bool transactions :1;
} _PoolTransactionsGetResult__isset;

class PoolTransactionsGetResult : public virtual ::apache::thrift::TBase {
 public:

  PoolTransactionsGetResult(const PoolTransactionsGetResult&);
  PoolTransactionsGetResult(PoolTransactionsGetResult&&);
  PoolTransactionsGetResult& operator=(const PoolTransactionsGetResult&);
  PoolTransactionsGetResult& operator=(PoolTransactionsGetResult&&);
  PoolTransactionsGetResult() {
  }

  virtual ~PoolTransactionsGetResult() throw();
   ::general::APIResponse status;
  std::vector<SealedTransaction>  transactions;

  _PoolTransactionsGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_transactions(const std::vector<SealedTransaction> & val);

  bool operator == (const PoolTransactionsGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(transactions == rhs.transactions))
      return false;
    return true;
  }
  bool operator != (const PoolTransactionsGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PoolTransactionsGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PoolTransactionsGetResult &a, PoolTransactionsGetResult &b);

std::ostream& operator<<(std::ostream& out, const PoolTransactionsGetResult& obj);

typedef struct _StatsGetResult__isset {
  _StatsGetResult__isset() : status(false), stats(false) {}
  bool status :1;
  bool stats :1;
} _StatsGetResult__isset;

class StatsGetResult : public virtual ::apache::thrift::TBase {
 public:

  StatsGetResult(const StatsGetResult&);
  StatsGetResult(StatsGetResult&&);
  StatsGetResult& operator=(const StatsGetResult&);
  StatsGetResult& operator=(StatsGetResult&&);
  StatsGetResult() {
  }

  virtual ~StatsGetResult() throw();
   ::general::APIResponse status;
  StatsPerPeriod stats;

  _StatsGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_stats(const StatsPerPeriod& val);

  bool operator == (const StatsGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(stats == rhs.stats))
      return false;
    return true;
  }
  bool operator != (const StatsGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StatsGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StatsGetResult &a, StatsGetResult &b);

std::ostream& operator<<(std::ostream& out, const StatsGetResult& obj);

typedef struct _SmartContractGetResult__isset {
  _SmartContractGetResult__isset() : status(false), smartContract(false) {}
  bool status :1;
  bool smartContract :1;
} _SmartContractGetResult__isset;

class SmartContractGetResult : public virtual ::apache::thrift::TBase {
 public:

  SmartContractGetResult(const SmartContractGetResult&);
  SmartContractGetResult(SmartContractGetResult&&);
  SmartContractGetResult& operator=(const SmartContractGetResult&);
  SmartContractGetResult& operator=(SmartContractGetResult&&);
  SmartContractGetResult() {
  }

  virtual ~SmartContractGetResult() throw();
   ::general::APIResponse status;
  SmartContract smartContract;

  _SmartContractGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_smartContract(const SmartContract& val);

  bool operator == (const SmartContractGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(smartContract == rhs.smartContract))
      return false;
    return true;
  }
  bool operator != (const SmartContractGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartContractGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartContractGetResult &a, SmartContractGetResult &b);

std::ostream& operator<<(std::ostream& out, const SmartContractGetResult& obj);

typedef struct _SmartContractAddressesListGetResult__isset {
  _SmartContractAddressesListGetResult__isset() : status(false), addressesList(false) {}
  bool status :1;
  bool addressesList :1;
} _SmartContractAddressesListGetResult__isset;

class SmartContractAddressesListGetResult : public virtual ::apache::thrift::TBase {
 public:

  SmartContractAddressesListGetResult(const SmartContractAddressesListGetResult&);
  SmartContractAddressesListGetResult(SmartContractAddressesListGetResult&&);
  SmartContractAddressesListGetResult& operator=(const SmartContractAddressesListGetResult&);
  SmartContractAddressesListGetResult& operator=(SmartContractAddressesListGetResult&&);
  SmartContractAddressesListGetResult() {
  }

  virtual ~SmartContractAddressesListGetResult() throw();
   ::general::APIResponse status;
  std::vector<Address>  addressesList;

  _SmartContractAddressesListGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_addressesList(const std::vector<Address> & val);

  bool operator == (const SmartContractAddressesListGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(addressesList == rhs.addressesList))
      return false;
    return true;
  }
  bool operator != (const SmartContractAddressesListGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartContractAddressesListGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartContractAddressesListGetResult &a, SmartContractAddressesListGetResult &b);

std::ostream& operator<<(std::ostream& out, const SmartContractAddressesListGetResult& obj);

typedef struct _SmartContractsListGetResult__isset {
  _SmartContractsListGetResult__isset() : status(false), count(false), smartContractsList(false) {}
  bool status :1;
  bool count :1;
  bool smartContractsList :1;
} _SmartContractsListGetResult__isset;

class SmartContractsListGetResult : public virtual ::apache::thrift::TBase {
 public:

  SmartContractsListGetResult(const SmartContractsListGetResult&);
  SmartContractsListGetResult(SmartContractsListGetResult&&);
  SmartContractsListGetResult& operator=(const SmartContractsListGetResult&);
  SmartContractsListGetResult& operator=(SmartContractsListGetResult&&);
  SmartContractsListGetResult() : count(0) {
  }

  virtual ~SmartContractsListGetResult() throw();
   ::general::APIResponse status;
  int32_t count;
  std::vector<SmartContract>  smartContractsList;

  _SmartContractsListGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_count(const int32_t val);

  void __set_smartContractsList(const std::vector<SmartContract> & val);

  bool operator == (const SmartContractsListGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(count == rhs.count))
      return false;
    if (!(smartContractsList == rhs.smartContractsList))
      return false;
    return true;
  }
  bool operator != (const SmartContractsListGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartContractsListGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartContractsListGetResult &a, SmartContractsListGetResult &b);

std::ostream& operator<<(std::ostream& out, const SmartContractsListGetResult& obj);

typedef struct _TransactionsStateGetResult__isset {
  _TransactionsStateGetResult__isset() : status(false), states(false), roundNum(false) {}
  bool status :1;
  bool states :1;
  bool roundNum :1;
} _TransactionsStateGetResult__isset;

class TransactionsStateGetResult : public virtual ::apache::thrift::TBase {
 public:

  TransactionsStateGetResult(const TransactionsStateGetResult&);
  TransactionsStateGetResult(TransactionsStateGetResult&&);
  TransactionsStateGetResult& operator=(const TransactionsStateGetResult&);
  TransactionsStateGetResult& operator=(TransactionsStateGetResult&&);
  TransactionsStateGetResult() : roundNum(0) {
  }

  virtual ~TransactionsStateGetResult() throw();
   ::general::APIResponse status;
  std::map<TransactionInnerId, TransactionState>  states;
  int32_t roundNum;

  _TransactionsStateGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_states(const std::map<TransactionInnerId, TransactionState> & val);

  void __set_roundNum(const int32_t val);

  bool operator == (const TransactionsStateGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(states == rhs.states))
      return false;
    if (!(roundNum == rhs.roundNum))
      return false;
    return true;
  }
  bool operator != (const TransactionsStateGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TransactionsStateGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TransactionsStateGetResult &a, TransactionsStateGetResult &b);

std::ostream& operator<<(std::ostream& out, const TransactionsStateGetResult& obj);

typedef struct _SmartMethodParamsGetResult__isset {
  _SmartMethodParamsGetResult__isset() : status(false), method(false), params(false) {}
  bool status :1;
  bool method :1;
  bool params :1;
} _SmartMethodParamsGetResult__isset;

class SmartMethodParamsGetResult : public virtual ::apache::thrift::TBase {
 public:

  SmartMethodParamsGetResult(const SmartMethodParamsGetResult&);
  SmartMethodParamsGetResult(SmartMethodParamsGetResult&&);
  SmartMethodParamsGetResult& operator=(const SmartMethodParamsGetResult&);
  SmartMethodParamsGetResult& operator=(SmartMethodParamsGetResult&&);
  SmartMethodParamsGetResult() : method() {
  }

  virtual ~SmartMethodParamsGetResult() throw();
   ::general::APIResponse status;
  std::string method;
  std::vector< ::general::Variant>  params;

  _SmartMethodParamsGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_method(const std::string& val);

  void __set_params(const std::vector< ::general::Variant> & val);

  bool operator == (const SmartMethodParamsGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(method == rhs.method))
      return false;
    if (!(params == rhs.params))
      return false;
    return true;
  }
  bool operator != (const SmartMethodParamsGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartMethodParamsGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartMethodParamsGetResult &a, SmartMethodParamsGetResult &b);

std::ostream& operator<<(std::ostream& out, const SmartMethodParamsGetResult& obj);

typedef struct _ContractAllMethodsGetResult__isset {
  _ContractAllMethodsGetResult__isset() : code(false), message(false), methods(false) {}
  bool code :1;
  bool message :1;
  bool methods :1;
} _ContractAllMethodsGetResult__isset;

class ContractAllMethodsGetResult : public virtual ::apache::thrift::TBase {
 public:

  ContractAllMethodsGetResult(const ContractAllMethodsGetResult&);
  ContractAllMethodsGetResult(ContractAllMethodsGetResult&&);
  ContractAllMethodsGetResult& operator=(const ContractAllMethodsGetResult&);
  ContractAllMethodsGetResult& operator=(ContractAllMethodsGetResult&&);
  ContractAllMethodsGetResult() : code(0), message() {
  }

  virtual ~ContractAllMethodsGetResult() throw();
  int8_t code;
  std::string message;
  std::vector< ::general::MethodDescription>  methods;

  _ContractAllMethodsGetResult__isset __isset;

  void __set_code(const int8_t val);

  void __set_message(const std::string& val);

  void __set_methods(const std::vector< ::general::MethodDescription> & val);

  bool operator == (const ContractAllMethodsGetResult & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (!(message == rhs.message))
      return false;
    if (!(methods == rhs.methods))
      return false;
    return true;
  }
  bool operator != (const ContractAllMethodsGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ContractAllMethodsGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ContractAllMethodsGetResult &a, ContractAllMethodsGetResult &b);

std::ostream& operator<<(std::ostream& out, const ContractAllMethodsGetResult& obj);

typedef struct _SmartContractMethodArgument__isset {
  _SmartContractMethodArgument__isset() : type(false), name(false) {}
  bool type :1;
  bool name :1;
} _SmartContractMethodArgument__isset;

class SmartContractMethodArgument : public virtual ::apache::thrift::TBase {
 public:

  SmartContractMethodArgument(const SmartContractMethodArgument&);
  SmartContractMethodArgument(SmartContractMethodArgument&&);
  SmartContractMethodArgument& operator=(const SmartContractMethodArgument&);
  SmartContractMethodArgument& operator=(SmartContractMethodArgument&&);
  SmartContractMethodArgument() : type(), name() {
  }

  virtual ~SmartContractMethodArgument() throw();
  std::string type;
  std::string name;

  _SmartContractMethodArgument__isset __isset;

  void __set_type(const std::string& val);

  void __set_name(const std::string& val);

  bool operator == (const SmartContractMethodArgument & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const SmartContractMethodArgument &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartContractMethodArgument & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartContractMethodArgument &a, SmartContractMethodArgument &b);

std::ostream& operator<<(std::ostream& out, const SmartContractMethodArgument& obj);

typedef struct _SmartContractMethod__isset {
  _SmartContractMethod__isset() : returnType(false), name(false), arguments(false) {}
  bool returnType :1;
  bool name :1;
  bool arguments :1;
} _SmartContractMethod__isset;

class SmartContractMethod : public virtual ::apache::thrift::TBase {
 public:

  SmartContractMethod(const SmartContractMethod&);
  SmartContractMethod(SmartContractMethod&&);
  SmartContractMethod& operator=(const SmartContractMethod&);
  SmartContractMethod& operator=(SmartContractMethod&&);
  SmartContractMethod() : returnType(), name() {
  }

  virtual ~SmartContractMethod() throw();
  std::string returnType;
  std::string name;
  std::vector<SmartContractMethodArgument>  arguments;

  _SmartContractMethod__isset __isset;

  void __set_returnType(const std::string& val);

  void __set_name(const std::string& val);

  void __set_arguments(const std::vector<SmartContractMethodArgument> & val);

  bool operator == (const SmartContractMethod & rhs) const
  {
    if (!(returnType == rhs.returnType))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(arguments == rhs.arguments))
      return false;
    return true;
  }
  bool operator != (const SmartContractMethod &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartContractMethod & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartContractMethod &a, SmartContractMethod &b);

std::ostream& operator<<(std::ostream& out, const SmartContractMethod& obj);

typedef struct _SmartContractDataResult__isset {
  _SmartContractDataResult__isset() : status(false), methods(false), variables(false) {}
  bool status :1;
  bool methods :1;
  bool variables :1;
} _SmartContractDataResult__isset;

class SmartContractDataResult : public virtual ::apache::thrift::TBase {
 public:

  SmartContractDataResult(const SmartContractDataResult&);
  SmartContractDataResult(SmartContractDataResult&&);
  SmartContractDataResult& operator=(const SmartContractDataResult&);
  SmartContractDataResult& operator=(SmartContractDataResult&&);
  SmartContractDataResult() {
  }

  virtual ~SmartContractDataResult() throw();
   ::general::APIResponse status;
  std::vector<SmartContractMethod>  methods;
  std::map<std::string,  ::general::Variant>  variables;

  _SmartContractDataResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_methods(const std::vector<SmartContractMethod> & val);

  void __set_variables(const std::map<std::string,  ::general::Variant> & val);

  bool operator == (const SmartContractDataResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(methods == rhs.methods))
      return false;
    if (!(variables == rhs.variables))
      return false;
    return true;
  }
  bool operator != (const SmartContractDataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartContractDataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartContractDataResult &a, SmartContractDataResult &b);

std::ostream& operator<<(std::ostream& out, const SmartContractDataResult& obj);

typedef struct _SmartContractCompileResult__isset {
  _SmartContractCompileResult__isset() : status(false), byteCodeObjects(false), ts(false) {}
  bool status :1;
  bool byteCodeObjects :1;
  bool ts :1;
} _SmartContractCompileResult__isset;

class SmartContractCompileResult : public virtual ::apache::thrift::TBase {
 public:

  SmartContractCompileResult(const SmartContractCompileResult&);
  SmartContractCompileResult(SmartContractCompileResult&&);
  SmartContractCompileResult& operator=(const SmartContractCompileResult&);
  SmartContractCompileResult& operator=(SmartContractCompileResult&&);
  SmartContractCompileResult() : ts((TokenStandart)0) {
  }

  virtual ~SmartContractCompileResult() throw();
   ::general::APIResponse status;
  std::vector< ::general::ByteCodeObject>  byteCodeObjects;
  TokenStandart ts;

  _SmartContractCompileResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_byteCodeObjects(const std::vector< ::general::ByteCodeObject> & val);

  void __set_ts(const TokenStandart val);

  bool operator == (const SmartContractCompileResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(byteCodeObjects == rhs.byteCodeObjects))
      return false;
    if (!(ts == rhs.ts))
      return false;
    return true;
  }
  bool operator != (const SmartContractCompileResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SmartContractCompileResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SmartContractCompileResult &a, SmartContractCompileResult &b);

std::ostream& operator<<(std::ostream& out, const SmartContractCompileResult& obj);

typedef struct _TokenInfo__isset {
  _TokenInfo__isset() : address(false), code(false), name(false), totalSupply(false), owner(false), transfersCount(false), transactionsCount(false), holdersCount(false), standart(false) {}
  bool address :1;
  bool code :1;
  bool name :1;
  bool totalSupply :1;
  bool owner :1;
  bool transfersCount :1;
  bool transactionsCount :1;
  bool holdersCount :1;
  bool standart :1;
} _TokenInfo__isset;

class TokenInfo : public virtual ::apache::thrift::TBase {
 public:

  TokenInfo(const TokenInfo&);
  TokenInfo(TokenInfo&&);
  TokenInfo& operator=(const TokenInfo&);
  TokenInfo& operator=(TokenInfo&&);
  TokenInfo() : address(), code(), name(), totalSupply(), owner(), transfersCount(0), transactionsCount(0), holdersCount(0), standart((TokenStandart)0) {
  }

  virtual ~TokenInfo() throw();
  Address address;
  TokenCode code;
  std::string name;
  TokenAmount totalSupply;
  Address owner;
  int32_t transfersCount;
  int32_t transactionsCount;
  int32_t holdersCount;
  TokenStandart standart;

  _TokenInfo__isset __isset;

  void __set_address(const Address& val);

  void __set_code(const TokenCode& val);

  void __set_name(const std::string& val);

  void __set_totalSupply(const TokenAmount& val);

  void __set_owner(const Address& val);

  void __set_transfersCount(const int32_t val);

  void __set_transactionsCount(const int32_t val);

  void __set_holdersCount(const int32_t val);

  void __set_standart(const TokenStandart val);

  bool operator == (const TokenInfo & rhs) const
  {
    if (!(address == rhs.address))
      return false;
    if (!(code == rhs.code))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(totalSupply == rhs.totalSupply))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (!(transfersCount == rhs.transfersCount))
      return false;
    if (!(transactionsCount == rhs.transactionsCount))
      return false;
    if (!(holdersCount == rhs.holdersCount))
      return false;
    if (!(standart == rhs.standart))
      return false;
    return true;
  }
  bool operator != (const TokenInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TokenInfo &a, TokenInfo &b);

std::ostream& operator<<(std::ostream& out, const TokenInfo& obj);

typedef struct _TokenTransaction__isset {
  _TokenTransaction__isset() : token(false), transaction(false), time(false), initiator(false), method(false), params(false) {}
  bool token :1;
  bool transaction :1;
  bool time :1;
  bool initiator :1;
  bool method :1;
  bool params :1;
} _TokenTransaction__isset;

class TokenTransaction : public virtual ::apache::thrift::TBase {
 public:

  TokenTransaction(const TokenTransaction&);
  TokenTransaction(TokenTransaction&&);
  TokenTransaction& operator=(const TokenTransaction&);
  TokenTransaction& operator=(TokenTransaction&&);
  TokenTransaction() : token(), time(0), initiator(), method() {
  }

  virtual ~TokenTransaction() throw();
  Address token;
  TransactionId transaction;
  Time time;
  Address initiator;
  std::string method;
  std::vector< ::general::Variant>  params;

  _TokenTransaction__isset __isset;

  void __set_token(const Address& val);

  void __set_transaction(const TransactionId& val);

  void __set_time(const Time val);

  void __set_initiator(const Address& val);

  void __set_method(const std::string& val);

  void __set_params(const std::vector< ::general::Variant> & val);

  bool operator == (const TokenTransaction & rhs) const
  {
    if (!(token == rhs.token))
      return false;
    if (!(transaction == rhs.transaction))
      return false;
    if (!(time == rhs.time))
      return false;
    if (!(initiator == rhs.initiator))
      return false;
    if (!(method == rhs.method))
      return false;
    if (!(params == rhs.params))
      return false;
    return true;
  }
  bool operator != (const TokenTransaction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenTransaction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TokenTransaction &a, TokenTransaction &b);

std::ostream& operator<<(std::ostream& out, const TokenTransaction& obj);

typedef struct _TokenHolder__isset {
  _TokenHolder__isset() : holder(false), token(false), balance(false), transfersCount(false) {}
  bool holder :1;
  bool token :1;
  bool balance :1;
  bool transfersCount :1;
} _TokenHolder__isset;

class TokenHolder : public virtual ::apache::thrift::TBase {
 public:

  TokenHolder(const TokenHolder&);
  TokenHolder(TokenHolder&&);
  TokenHolder& operator=(const TokenHolder&);
  TokenHolder& operator=(TokenHolder&&);
  TokenHolder() : holder(), token(), balance(), transfersCount(0) {
  }

  virtual ~TokenHolder() throw();
  Address holder;
  Address token;
  TokenAmount balance;
  int32_t transfersCount;

  _TokenHolder__isset __isset;

  void __set_holder(const Address& val);

  void __set_token(const Address& val);

  void __set_balance(const TokenAmount& val);

  void __set_transfersCount(const int32_t val);

  bool operator == (const TokenHolder & rhs) const
  {
    if (!(holder == rhs.holder))
      return false;
    if (!(token == rhs.token))
      return false;
    if (!(balance == rhs.balance))
      return false;
    if (!(transfersCount == rhs.transfersCount))
      return false;
    return true;
  }
  bool operator != (const TokenHolder &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenHolder & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TokenHolder &a, TokenHolder &b);

std::ostream& operator<<(std::ostream& out, const TokenHolder& obj);

typedef struct _TokenBalance__isset {
  _TokenBalance__isset() : token(false), code(false), name(false), balance(false) {}
  bool token :1;
  bool code :1;
  bool name :1;
  bool balance :1;
} _TokenBalance__isset;

class TokenBalance : public virtual ::apache::thrift::TBase {
 public:

  TokenBalance(const TokenBalance&);
  TokenBalance(TokenBalance&&);
  TokenBalance& operator=(const TokenBalance&);
  TokenBalance& operator=(TokenBalance&&);
  TokenBalance() : token(), code(), name(), balance() {
  }

  virtual ~TokenBalance() throw();
  Address token;
  TokenCode code;
  std::string name;
  TokenAmount balance;

  _TokenBalance__isset __isset;

  void __set_token(const Address& val);

  void __set_code(const TokenCode& val);

  void __set_name(const std::string& val);

  void __set_balance(const TokenAmount& val);

  bool operator == (const TokenBalance & rhs) const
  {
    if (!(token == rhs.token))
      return false;
    if (!(code == rhs.code))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(balance == rhs.balance))
      return false;
    return true;
  }
  bool operator != (const TokenBalance &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenBalance & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TokenBalance &a, TokenBalance &b);

std::ostream& operator<<(std::ostream& out, const TokenBalance& obj);

typedef struct _TokenBalancesResult__isset {
  _TokenBalancesResult__isset() : status(false), balances(false) {}
  bool status :1;
  bool balances :1;
} _TokenBalancesResult__isset;

class TokenBalancesResult : public virtual ::apache::thrift::TBase {
 public:

  TokenBalancesResult(const TokenBalancesResult&);
  TokenBalancesResult(TokenBalancesResult&&);
  TokenBalancesResult& operator=(const TokenBalancesResult&);
  TokenBalancesResult& operator=(TokenBalancesResult&&);
  TokenBalancesResult() {
  }

  virtual ~TokenBalancesResult() throw();
   ::general::APIResponse status;
  std::vector<TokenBalance>  balances;

  _TokenBalancesResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_balances(const std::vector<TokenBalance> & val);

  bool operator == (const TokenBalancesResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(balances == rhs.balances))
      return false;
    return true;
  }
  bool operator != (const TokenBalancesResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenBalancesResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TokenBalancesResult &a, TokenBalancesResult &b);

std::ostream& operator<<(std::ostream& out, const TokenBalancesResult& obj);

typedef struct _TokenTransfer__isset {
  _TokenTransfer__isset() : token(false), code(false), sender(false), receiver(false), amount(false), initiator(false), transaction(false), time(false) {}
  bool token :1;
  bool code :1;
  bool sender :1;
  bool receiver :1;
  bool amount :1;
  bool initiator :1;
  bool transaction :1;
  bool time :1;
} _TokenTransfer__isset;

class TokenTransfer : public virtual ::apache::thrift::TBase {
 public:

  TokenTransfer(const TokenTransfer&);
  TokenTransfer(TokenTransfer&&);
  TokenTransfer& operator=(const TokenTransfer&);
  TokenTransfer& operator=(TokenTransfer&&);
  TokenTransfer() : token(), code(), sender(), receiver(), amount(), initiator(), time(0) {
  }

  virtual ~TokenTransfer() throw();
  Address token;
  TokenCode code;
  Address sender;
  Address receiver;
  TokenAmount amount;
  Address initiator;
  TransactionId transaction;
  Time time;

  _TokenTransfer__isset __isset;

  void __set_token(const Address& val);

  void __set_code(const TokenCode& val);

  void __set_sender(const Address& val);

  void __set_receiver(const Address& val);

  void __set_amount(const TokenAmount& val);

  void __set_initiator(const Address& val);

  void __set_transaction(const TransactionId& val);

  void __set_time(const Time val);

  bool operator == (const TokenTransfer & rhs) const
  {
    if (!(token == rhs.token))
      return false;
    if (!(code == rhs.code))
      return false;
    if (!(sender == rhs.sender))
      return false;
    if (!(receiver == rhs.receiver))
      return false;
    if (!(amount == rhs.amount))
      return false;
    if (!(initiator == rhs.initiator))
      return false;
    if (!(transaction == rhs.transaction))
      return false;
    if (!(time == rhs.time))
      return false;
    return true;
  }
  bool operator != (const TokenTransfer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenTransfer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TokenTransfer &a, TokenTransfer &b);

std::ostream& operator<<(std::ostream& out, const TokenTransfer& obj);

typedef struct _TokenTransfersResult__isset {
  _TokenTransfersResult__isset() : status(false), count(false), transfers(false) {}
  bool status :1;
  bool count :1;
  bool transfers :1;
} _TokenTransfersResult__isset;

class TokenTransfersResult : public virtual ::apache::thrift::TBase {
 public:

  TokenTransfersResult(const TokenTransfersResult&);
  TokenTransfersResult(TokenTransfersResult&&);
  TokenTransfersResult& operator=(const TokenTransfersResult&);
  TokenTransfersResult& operator=(TokenTransfersResult&&);
  TokenTransfersResult() : count(0) {
  }

  virtual ~TokenTransfersResult() throw();
   ::general::APIResponse status;
  int32_t count;
  std::vector<TokenTransfer>  transfers;

  _TokenTransfersResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_count(const int32_t val);

  void __set_transfers(const std::vector<TokenTransfer> & val);

  bool operator == (const TokenTransfersResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(count == rhs.count))
      return false;
    if (!(transfers == rhs.transfers))
      return false;
    return true;
  }
  bool operator != (const TokenTransfersResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenTransfersResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TokenTransfersResult &a, TokenTransfersResult &b);

std::ostream& operator<<(std::ostream& out, const TokenTransfersResult& obj);

typedef struct _TokenTransactionsResult__isset {
  _TokenTransactionsResult__isset() : status(false), count(false), transactions(false) {}
  bool status :1;
  bool count :1;
  bool transactions :1;
} _TokenTransactionsResult__isset;

class TokenTransactionsResult : public virtual ::apache::thrift::TBase {
 public:

  TokenTransactionsResult(const TokenTransactionsResult&);
  TokenTransactionsResult(TokenTransactionsResult&&);
  TokenTransactionsResult& operator=(const TokenTransactionsResult&);
  TokenTransactionsResult& operator=(TokenTransactionsResult&&);
  TokenTransactionsResult() : count(0) {
  }

  virtual ~TokenTransactionsResult() throw();
   ::general::APIResponse status;
  int32_t count;
  std::vector<TokenTransaction>  transactions;

  _TokenTransactionsResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_count(const int32_t val);

  void __set_transactions(const std::vector<TokenTransaction> & val);

  bool operator == (const TokenTransactionsResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(count == rhs.count))
      return false;
    if (!(transactions == rhs.transactions))
      return false;
    return true;
  }
  bool operator != (const TokenTransactionsResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenTransactionsResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TokenTransactionsResult &a, TokenTransactionsResult &b);

std::ostream& operator<<(std::ostream& out, const TokenTransactionsResult& obj);

typedef struct _TokenInfoResult__isset {
  _TokenInfoResult__isset() : status(false), token(false) {}
  bool status :1;
  bool token :1;
} _TokenInfoResult__isset;

class TokenInfoResult : public virtual ::apache::thrift::TBase {
 public:

  TokenInfoResult(const TokenInfoResult&);
  TokenInfoResult(TokenInfoResult&&);
  TokenInfoResult& operator=(const TokenInfoResult&);
  TokenInfoResult& operator=(TokenInfoResult&&);
  TokenInfoResult() {
  }

  virtual ~TokenInfoResult() throw();
   ::general::APIResponse status;
  TokenInfo token;

  _TokenInfoResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_token(const TokenInfo& val);

  bool operator == (const TokenInfoResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(token == rhs.token))
      return false;
    return true;
  }
  bool operator != (const TokenInfoResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenInfoResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TokenInfoResult &a, TokenInfoResult &b);

std::ostream& operator<<(std::ostream& out, const TokenInfoResult& obj);

typedef struct _TokenHoldersResult__isset {
  _TokenHoldersResult__isset() : status(false), count(false), holders(false) {}
  bool status :1;
  bool count :1;
  bool holders :1;
} _TokenHoldersResult__isset;

class TokenHoldersResult : public virtual ::apache::thrift::TBase {
 public:

  TokenHoldersResult(const TokenHoldersResult&);
  TokenHoldersResult(TokenHoldersResult&&);
  TokenHoldersResult& operator=(const TokenHoldersResult&);
  TokenHoldersResult& operator=(TokenHoldersResult&&);
  TokenHoldersResult() : count(0) {
  }

  virtual ~TokenHoldersResult() throw();
   ::general::APIResponse status;
  int32_t count;
  std::vector<TokenHolder>  holders;

  _TokenHoldersResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_count(const int32_t val);

  void __set_holders(const std::vector<TokenHolder> & val);

  bool operator == (const TokenHoldersResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(count == rhs.count))
      return false;
    if (!(holders == rhs.holders))
      return false;
    return true;
  }
  bool operator != (const TokenHoldersResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenHoldersResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TokenHoldersResult &a, TokenHoldersResult &b);

std::ostream& operator<<(std::ostream& out, const TokenHoldersResult& obj);

typedef struct _TokensListResult__isset {
  _TokensListResult__isset() : status(false), count(false), tokens(false) {}
  bool status :1;
  bool count :1;
  bool tokens :1;
} _TokensListResult__isset;

class TokensListResult : public virtual ::apache::thrift::TBase {
 public:

  TokensListResult(const TokensListResult&);
  TokensListResult(TokensListResult&&);
  TokensListResult& operator=(const TokensListResult&);
  TokensListResult& operator=(TokensListResult&&);
  TokensListResult() : count(0) {
  }

  virtual ~TokensListResult() throw();
   ::general::APIResponse status;
  int32_t count;
  std::vector<TokenInfo>  tokens;

  _TokensListResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_count(const int32_t val);

  void __set_tokens(const std::vector<TokenInfo> & val);

  bool operator == (const TokensListResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(count == rhs.count))
      return false;
    if (!(tokens == rhs.tokens))
      return false;
    return true;
  }
  bool operator != (const TokensListResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokensListResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TokensListResult &a, TokensListResult &b);

std::ostream& operator<<(std::ostream& out, const TokensListResult& obj);

typedef struct _WalletInfo__isset {
  _WalletInfo__isset() : address(false), balance(false), transactionsNumber(false), firstTransactionTime(false) {}
  bool address :1;
  bool balance :1;
  bool transactionsNumber :1;
  bool firstTransactionTime :1;
} _WalletInfo__isset;

class WalletInfo : public virtual ::apache::thrift::TBase {
 public:

  WalletInfo(const WalletInfo&);
  WalletInfo(WalletInfo&&);
  WalletInfo& operator=(const WalletInfo&);
  WalletInfo& operator=(WalletInfo&&);
  WalletInfo() : address(), transactionsNumber(0), firstTransactionTime(0) {
  }

  virtual ~WalletInfo() throw();
  Address address;
  Amount balance;
  int64_t transactionsNumber;
  Time firstTransactionTime;

  _WalletInfo__isset __isset;

  void __set_address(const Address& val);

  void __set_balance(const Amount& val);

  void __set_transactionsNumber(const int64_t val);

  void __set_firstTransactionTime(const Time val);

  bool operator == (const WalletInfo & rhs) const
  {
    if (!(address == rhs.address))
      return false;
    if (!(balance == rhs.balance))
      return false;
    if (!(transactionsNumber == rhs.transactionsNumber))
      return false;
    if (!(firstTransactionTime == rhs.firstTransactionTime))
      return false;
    return true;
  }
  bool operator != (const WalletInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WalletInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WalletInfo &a, WalletInfo &b);

std::ostream& operator<<(std::ostream& out, const WalletInfo& obj);

typedef struct _WalletsGetResult__isset {
  _WalletsGetResult__isset() : status(false), count(false), wallets(false) {}
  bool status :1;
  bool count :1;
  bool wallets :1;
} _WalletsGetResult__isset;

class WalletsGetResult : public virtual ::apache::thrift::TBase {
 public:

  WalletsGetResult(const WalletsGetResult&);
  WalletsGetResult(WalletsGetResult&&);
  WalletsGetResult& operator=(const WalletsGetResult&);
  WalletsGetResult& operator=(WalletsGetResult&&);
  WalletsGetResult() : count(0) {
  }

  virtual ~WalletsGetResult() throw();
   ::general::APIResponse status;
  int32_t count;
  std::vector<WalletInfo>  wallets;

  _WalletsGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_count(const int32_t val);

  void __set_wallets(const std::vector<WalletInfo> & val);

  bool operator == (const WalletsGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(count == rhs.count))
      return false;
    if (!(wallets == rhs.wallets))
      return false;
    return true;
  }
  bool operator != (const WalletsGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WalletsGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WalletsGetResult &a, WalletsGetResult &b);

std::ostream& operator<<(std::ostream& out, const WalletsGetResult& obj);

typedef struct _TrustedInfo__isset {
  _TrustedInfo__isset() : address(false), timesWriter(false), timesTrusted(false), feeCollected(false) {}
  bool address :1;
  bool timesWriter :1;
  bool timesTrusted :1;
  bool feeCollected :1;
} _TrustedInfo__isset;

class TrustedInfo : public virtual ::apache::thrift::TBase {
 public:

  TrustedInfo(const TrustedInfo&);
  TrustedInfo(TrustedInfo&&);
  TrustedInfo& operator=(const TrustedInfo&);
  TrustedInfo& operator=(TrustedInfo&&);
  TrustedInfo() : address(), timesWriter(0), timesTrusted(0) {
  }

  virtual ~TrustedInfo() throw();
  Address address;
  int32_t timesWriter;
  int32_t timesTrusted;
  Amount feeCollected;

  _TrustedInfo__isset __isset;

  void __set_address(const Address& val);

  void __set_timesWriter(const int32_t val);

  void __set_timesTrusted(const int32_t val);

  void __set_feeCollected(const Amount& val);

  bool operator == (const TrustedInfo & rhs) const
  {
    if (!(address == rhs.address))
      return false;
    if (!(timesWriter == rhs.timesWriter))
      return false;
    if (!(timesTrusted == rhs.timesTrusted))
      return false;
    if (!(feeCollected == rhs.feeCollected))
      return false;
    return true;
  }
  bool operator != (const TrustedInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TrustedInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TrustedInfo &a, TrustedInfo &b);

std::ostream& operator<<(std::ostream& out, const TrustedInfo& obj);

typedef struct _TrustedGetResult__isset {
  _TrustedGetResult__isset() : status(false), pages(false), writers(false) {}
  bool status :1;
  bool pages :1;
  bool writers :1;
} _TrustedGetResult__isset;

class TrustedGetResult : public virtual ::apache::thrift::TBase {
 public:

  TrustedGetResult(const TrustedGetResult&);
  TrustedGetResult(TrustedGetResult&&);
  TrustedGetResult& operator=(const TrustedGetResult&);
  TrustedGetResult& operator=(TrustedGetResult&&);
  TrustedGetResult() : pages(0) {
  }

  virtual ~TrustedGetResult() throw();
   ::general::APIResponse status;
  int32_t pages;
  std::vector<TrustedInfo>  writers;

  _TrustedGetResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_pages(const int32_t val);

  void __set_writers(const std::vector<TrustedInfo> & val);

  bool operator == (const TrustedGetResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(pages == rhs.pages))
      return false;
    if (!(writers == rhs.writers))
      return false;
    return true;
  }
  bool operator != (const TrustedGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TrustedGetResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TrustedGetResult &a, TrustedGetResult &b);

std::ostream& operator<<(std::ostream& out, const TrustedGetResult& obj);

typedef struct _SyncStateResult__isset {
  _SyncStateResult__isset() : status(false), currRound(false), lastBlock(false) {}
  bool status :1;
  bool currRound :1;
  bool lastBlock :1;
} _SyncStateResult__isset;

class SyncStateResult : public virtual ::apache::thrift::TBase {
 public:

  SyncStateResult(const SyncStateResult&);
  SyncStateResult(SyncStateResult&&);
  SyncStateResult& operator=(const SyncStateResult&);
  SyncStateResult& operator=(SyncStateResult&&);
  SyncStateResult() : currRound(0), lastBlock(0) {
  }

  virtual ~SyncStateResult() throw();
   ::general::APIResponse status;
  int64_t currRound;
  int64_t lastBlock;

  _SyncStateResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_currRound(const int64_t val);

  void __set_lastBlock(const int64_t val);

  bool operator == (const SyncStateResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(currRound == rhs.currRound))
      return false;
    if (!(lastBlock == rhs.lastBlock))
      return false;
    return true;
  }
  bool operator != (const SyncStateResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SyncStateResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SyncStateResult &a, SyncStateResult &b);

std::ostream& operator<<(std::ostream& out, const SyncStateResult& obj);

typedef struct _GetSeedResult__isset {
  _GetSeedResult__isset() : status(false), seed(false) {}
  bool status :1;
  bool seed :1;
} _GetSeedResult__isset;

class GetSeedResult : public virtual ::apache::thrift::TBase {
 public:

  GetSeedResult(const GetSeedResult&);
  GetSeedResult(GetSeedResult&&);
  GetSeedResult& operator=(const GetSeedResult&);
  GetSeedResult& operator=(GetSeedResult&&);
  GetSeedResult() : seed() {
  }

  virtual ~GetSeedResult() throw();
   ::general::APIResponse status;
  std::string seed;

  _GetSeedResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_seed(const std::string& val);

  bool operator == (const GetSeedResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(seed == rhs.seed))
      return false;
    return true;
  }
  bool operator != (const GetSeedResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetSeedResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetSeedResult &a, GetSeedResult &b);

std::ostream& operator<<(std::ostream& out, const GetSeedResult& obj);

typedef struct _GetSmartCodeResult__isset {
  _GetSmartCodeResult__isset() : status(false), byteCodeObjects(false), contractState(false) {}
  bool status :1;
  bool byteCodeObjects :1;
  bool contractState :1;
} _GetSmartCodeResult__isset;

class GetSmartCodeResult : public virtual ::apache::thrift::TBase {
 public:

  GetSmartCodeResult(const GetSmartCodeResult&);
  GetSmartCodeResult(GetSmartCodeResult&&);
  GetSmartCodeResult& operator=(const GetSmartCodeResult&);
  GetSmartCodeResult& operator=(GetSmartCodeResult&&);
  GetSmartCodeResult() : contractState() {
  }

  virtual ~GetSmartCodeResult() throw();
   ::general::APIResponse status;
  std::vector< ::general::ByteCodeObject>  byteCodeObjects;
  std::string contractState;

  _GetSmartCodeResult__isset __isset;

  void __set_status(const  ::general::APIResponse& val);

  void __set_byteCodeObjects(const std::vector< ::general::ByteCodeObject> & val);

  void __set_contractState(const std::string& val);

  bool operator == (const GetSmartCodeResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(byteCodeObjects == rhs.byteCodeObjects))
      return false;
    if (!(contractState == rhs.contractState))
      return false;
    return true;
  }
  bool operator != (const GetSmartCodeResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetSmartCodeResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetSmartCodeResult &a, GetSmartCodeResult &b);

std::ostream& operator<<(std::ostream& out, const GetSmartCodeResult& obj);

} // namespace

#endif
