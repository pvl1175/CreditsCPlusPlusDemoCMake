/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "general_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace general {


Variant::~Variant() throw() {
}


void Variant::__set_v_null(const int8_t val) {
  this->v_null = val;
__isset.v_null = true;
}

void Variant::__set_v_boolean(const bool val) {
  this->v_boolean = val;
__isset.v_boolean = true;
}

void Variant::__set_v_boolean_box(const bool val) {
  this->v_boolean_box = val;
__isset.v_boolean_box = true;
}

void Variant::__set_v_byte(const int8_t val) {
  this->v_byte = val;
__isset.v_byte = true;
}

void Variant::__set_v_byte_box(const int8_t val) {
  this->v_byte_box = val;
__isset.v_byte_box = true;
}

void Variant::__set_v_short(const int16_t val) {
  this->v_short = val;
__isset.v_short = true;
}

void Variant::__set_v_short_box(const int16_t val) {
  this->v_short_box = val;
__isset.v_short_box = true;
}

void Variant::__set_v_int(const int32_t val) {
  this->v_int = val;
__isset.v_int = true;
}

void Variant::__set_v_int_box(const int32_t val) {
  this->v_int_box = val;
__isset.v_int_box = true;
}

void Variant::__set_v_long(const int64_t val) {
  this->v_long = val;
__isset.v_long = true;
}

void Variant::__set_v_long_box(const int64_t val) {
  this->v_long_box = val;
__isset.v_long_box = true;
}

void Variant::__set_v_float(const double val) {
  this->v_float = val;
__isset.v_float = true;
}

void Variant::__set_v_float_box(const double val) {
  this->v_float_box = val;
__isset.v_float_box = true;
}

void Variant::__set_v_double(const double val) {
  this->v_double = val;
__isset.v_double = true;
}

void Variant::__set_v_double_box(const double val) {
  this->v_double_box = val;
__isset.v_double_box = true;
}

void Variant::__set_v_string(const std::string& val) {
  this->v_string = val;
__isset.v_string = true;
}

void Variant::__set_v_list(const std::vector<Variant> & val) {
  this->v_list = val;
__isset.v_list = true;
}

void Variant::__set_v_set(const std::set<Variant> & val) {
  this->v_set = val;
__isset.v_set = true;
}

void Variant::__set_v_map(const std::map<Variant, Variant> & val) {
  this->v_map = val;
__isset.v_map = true;
}

void Variant::__set_v_array(const std::vector<Variant> & val) {
  this->v_array = val;
__isset.v_array = true;
}
std::ostream& operator<<(std::ostream& out, const Variant& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Variant::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->v_null);
          this->__isset.v_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->v_boolean);
          this->__isset.v_boolean = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->v_boolean_box);
          this->__isset.v_boolean_box = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->v_byte);
          this->__isset.v_byte = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->v_byte_box);
          this->__isset.v_byte_box = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->v_short);
          this->__isset.v_short = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->v_short_box);
          this->__isset.v_short_box = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->v_int);
          this->__isset.v_int = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->v_int_box);
          this->__isset.v_int_box = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v_long);
          this->__isset.v_long = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v_long_box);
          this->__isset.v_long_box = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v_float);
          this->__isset.v_float = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v_float_box);
          this->__isset.v_float_box = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v_double);
          this->__isset.v_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v_double_box);
          this->__isset.v_double_box = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->v_string);
          this->__isset.v_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_list.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->v_list.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->v_list[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->v_set.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readSetBegin(_etype8, _size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              Variant _elem10;
              xfer += _elem10.read(iprot);
              this->v_set.insert(_elem10);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.v_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->v_map.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _ktype12;
            ::apache::thrift::protocol::TType _vtype13;
            xfer += iprot->readMapBegin(_ktype12, _vtype13, _size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              Variant _key16;
              xfer += _key16.read(iprot);
              Variant& _val17 = this->v_map[_key16];
              xfer += _val17.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.v_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_array.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->v_array.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += this->v_array[_i22].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_array = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Variant::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Variant");

  if (this->__isset.v_null) {
    xfer += oprot->writeFieldBegin("v_null", ::apache::thrift::protocol::T_BYTE, 1);
    xfer += oprot->writeByte(this->v_null);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_boolean) {
    xfer += oprot->writeFieldBegin("v_boolean", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->v_boolean);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_boolean_box) {
    xfer += oprot->writeFieldBegin("v_boolean_box", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->v_boolean_box);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_byte) {
    xfer += oprot->writeFieldBegin("v_byte", ::apache::thrift::protocol::T_BYTE, 4);
    xfer += oprot->writeByte(this->v_byte);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_byte_box) {
    xfer += oprot->writeFieldBegin("v_byte_box", ::apache::thrift::protocol::T_BYTE, 5);
    xfer += oprot->writeByte(this->v_byte_box);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_short) {
    xfer += oprot->writeFieldBegin("v_short", ::apache::thrift::protocol::T_I16, 6);
    xfer += oprot->writeI16(this->v_short);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_short_box) {
    xfer += oprot->writeFieldBegin("v_short_box", ::apache::thrift::protocol::T_I16, 7);
    xfer += oprot->writeI16(this->v_short_box);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_int) {
    xfer += oprot->writeFieldBegin("v_int", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->v_int);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_int_box) {
    xfer += oprot->writeFieldBegin("v_int_box", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->v_int_box);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_long) {
    xfer += oprot->writeFieldBegin("v_long", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->v_long);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_long_box) {
    xfer += oprot->writeFieldBegin("v_long_box", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->v_long_box);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_float) {
    xfer += oprot->writeFieldBegin("v_float", ::apache::thrift::protocol::T_DOUBLE, 12);
    xfer += oprot->writeDouble(this->v_float);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_float_box) {
    xfer += oprot->writeFieldBegin("v_float_box", ::apache::thrift::protocol::T_DOUBLE, 13);
    xfer += oprot->writeDouble(this->v_float_box);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_double) {
    xfer += oprot->writeFieldBegin("v_double", ::apache::thrift::protocol::T_DOUBLE, 14);
    xfer += oprot->writeDouble(this->v_double);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_double_box) {
    xfer += oprot->writeFieldBegin("v_double_box", ::apache::thrift::protocol::T_DOUBLE, 15);
    xfer += oprot->writeDouble(this->v_double_box);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_string) {
    xfer += oprot->writeFieldBegin("v_string", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->v_string);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_list) {
    xfer += oprot->writeFieldBegin("v_list", ::apache::thrift::protocol::T_LIST, 17);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v_list.size()));
      std::vector<Variant> ::const_iterator _iter23;
      for (_iter23 = this->v_list.begin(); _iter23 != this->v_list.end(); ++_iter23)
      {
        xfer += (*_iter23).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_set) {
    xfer += oprot->writeFieldBegin("v_set", ::apache::thrift::protocol::T_SET, 18);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v_set.size()));
      std::set<Variant> ::const_iterator _iter24;
      for (_iter24 = this->v_set.begin(); _iter24 != this->v_set.end(); ++_iter24)
      {
        xfer += (*_iter24).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_map) {
    xfer += oprot->writeFieldBegin("v_map", ::apache::thrift::protocol::T_MAP, 19);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v_map.size()));
      std::map<Variant, Variant> ::const_iterator _iter25;
      for (_iter25 = this->v_map.begin(); _iter25 != this->v_map.end(); ++_iter25)
      {
        xfer += _iter25->first.write(oprot);
        xfer += _iter25->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_array) {
    xfer += oprot->writeFieldBegin("v_array", ::apache::thrift::protocol::T_LIST, 20);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v_array.size()));
      std::vector<Variant> ::const_iterator _iter26;
      for (_iter26 = this->v_array.begin(); _iter26 != this->v_array.end(); ++_iter26)
      {
        xfer += (*_iter26).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Variant &a, Variant &b) {
  using ::std::swap;
  swap(a.v_null, b.v_null);
  swap(a.v_boolean, b.v_boolean);
  swap(a.v_boolean_box, b.v_boolean_box);
  swap(a.v_byte, b.v_byte);
  swap(a.v_byte_box, b.v_byte_box);
  swap(a.v_short, b.v_short);
  swap(a.v_short_box, b.v_short_box);
  swap(a.v_int, b.v_int);
  swap(a.v_int_box, b.v_int_box);
  swap(a.v_long, b.v_long);
  swap(a.v_long_box, b.v_long_box);
  swap(a.v_float, b.v_float);
  swap(a.v_float_box, b.v_float_box);
  swap(a.v_double, b.v_double);
  swap(a.v_double_box, b.v_double_box);
  swap(a.v_string, b.v_string);
  swap(a.v_list, b.v_list);
  swap(a.v_set, b.v_set);
  swap(a.v_map, b.v_map);
  swap(a.v_array, b.v_array);
  swap(a.__isset, b.__isset);
}

Variant::Variant(const Variant& other27) {
  v_null = other27.v_null;
  v_boolean = other27.v_boolean;
  v_boolean_box = other27.v_boolean_box;
  v_byte = other27.v_byte;
  v_byte_box = other27.v_byte_box;
  v_short = other27.v_short;
  v_short_box = other27.v_short_box;
  v_int = other27.v_int;
  v_int_box = other27.v_int_box;
  v_long = other27.v_long;
  v_long_box = other27.v_long_box;
  v_float = other27.v_float;
  v_float_box = other27.v_float_box;
  v_double = other27.v_double;
  v_double_box = other27.v_double_box;
  v_string = other27.v_string;
  v_list = other27.v_list;
  v_set = other27.v_set;
  v_map = other27.v_map;
  v_array = other27.v_array;
  __isset = other27.__isset;
}
Variant::Variant( Variant&& other28) {
  v_null = std::move(other28.v_null);
  v_boolean = std::move(other28.v_boolean);
  v_boolean_box = std::move(other28.v_boolean_box);
  v_byte = std::move(other28.v_byte);
  v_byte_box = std::move(other28.v_byte_box);
  v_short = std::move(other28.v_short);
  v_short_box = std::move(other28.v_short_box);
  v_int = std::move(other28.v_int);
  v_int_box = std::move(other28.v_int_box);
  v_long = std::move(other28.v_long);
  v_long_box = std::move(other28.v_long_box);
  v_float = std::move(other28.v_float);
  v_float_box = std::move(other28.v_float_box);
  v_double = std::move(other28.v_double);
  v_double_box = std::move(other28.v_double_box);
  v_string = std::move(other28.v_string);
  v_list = std::move(other28.v_list);
  v_set = std::move(other28.v_set);
  v_map = std::move(other28.v_map);
  v_array = std::move(other28.v_array);
  __isset = std::move(other28.__isset);
}
Variant& Variant::operator=(const Variant& other29) {
  v_null = other29.v_null;
  v_boolean = other29.v_boolean;
  v_boolean_box = other29.v_boolean_box;
  v_byte = other29.v_byte;
  v_byte_box = other29.v_byte_box;
  v_short = other29.v_short;
  v_short_box = other29.v_short_box;
  v_int = other29.v_int;
  v_int_box = other29.v_int_box;
  v_long = other29.v_long;
  v_long_box = other29.v_long_box;
  v_float = other29.v_float;
  v_float_box = other29.v_float_box;
  v_double = other29.v_double;
  v_double_box = other29.v_double_box;
  v_string = other29.v_string;
  v_list = other29.v_list;
  v_set = other29.v_set;
  v_map = other29.v_map;
  v_array = other29.v_array;
  __isset = other29.__isset;
  return *this;
}
Variant& Variant::operator=(Variant&& other30) {
  v_null = std::move(other30.v_null);
  v_boolean = std::move(other30.v_boolean);
  v_boolean_box = std::move(other30.v_boolean_box);
  v_byte = std::move(other30.v_byte);
  v_byte_box = std::move(other30.v_byte_box);
  v_short = std::move(other30.v_short);
  v_short_box = std::move(other30.v_short_box);
  v_int = std::move(other30.v_int);
  v_int_box = std::move(other30.v_int_box);
  v_long = std::move(other30.v_long);
  v_long_box = std::move(other30.v_long_box);
  v_float = std::move(other30.v_float);
  v_float_box = std::move(other30.v_float_box);
  v_double = std::move(other30.v_double);
  v_double_box = std::move(other30.v_double_box);
  v_string = std::move(other30.v_string);
  v_list = std::move(other30.v_list);
  v_set = std::move(other30.v_set);
  v_map = std::move(other30.v_map);
  v_array = std::move(other30.v_array);
  __isset = std::move(other30.__isset);
  return *this;
}
void Variant::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Variant(";
  out << "v_null="; (__isset.v_null ? (out << to_string(v_null)) : (out << "<null>"));
  out << ", " << "v_boolean="; (__isset.v_boolean ? (out << to_string(v_boolean)) : (out << "<null>"));
  out << ", " << "v_boolean_box="; (__isset.v_boolean_box ? (out << to_string(v_boolean_box)) : (out << "<null>"));
  out << ", " << "v_byte="; (__isset.v_byte ? (out << to_string(v_byte)) : (out << "<null>"));
  out << ", " << "v_byte_box="; (__isset.v_byte_box ? (out << to_string(v_byte_box)) : (out << "<null>"));
  out << ", " << "v_short="; (__isset.v_short ? (out << to_string(v_short)) : (out << "<null>"));
  out << ", " << "v_short_box="; (__isset.v_short_box ? (out << to_string(v_short_box)) : (out << "<null>"));
  out << ", " << "v_int="; (__isset.v_int ? (out << to_string(v_int)) : (out << "<null>"));
  out << ", " << "v_int_box="; (__isset.v_int_box ? (out << to_string(v_int_box)) : (out << "<null>"));
  out << ", " << "v_long="; (__isset.v_long ? (out << to_string(v_long)) : (out << "<null>"));
  out << ", " << "v_long_box="; (__isset.v_long_box ? (out << to_string(v_long_box)) : (out << "<null>"));
  out << ", " << "v_float="; (__isset.v_float ? (out << to_string(v_float)) : (out << "<null>"));
  out << ", " << "v_float_box="; (__isset.v_float_box ? (out << to_string(v_float_box)) : (out << "<null>"));
  out << ", " << "v_double="; (__isset.v_double ? (out << to_string(v_double)) : (out << "<null>"));
  out << ", " << "v_double_box="; (__isset.v_double_box ? (out << to_string(v_double_box)) : (out << "<null>"));
  out << ", " << "v_string="; (__isset.v_string ? (out << to_string(v_string)) : (out << "<null>"));
  out << ", " << "v_list="; (__isset.v_list ? (out << to_string(v_list)) : (out << "<null>"));
  out << ", " << "v_set="; (__isset.v_set ? (out << to_string(v_set)) : (out << "<null>"));
  out << ", " << "v_map="; (__isset.v_map ? (out << to_string(v_map)) : (out << "<null>"));
  out << ", " << "v_array="; (__isset.v_array ? (out << to_string(v_array)) : (out << "<null>"));
  out << ")";
}


MethodArgument::~MethodArgument() throw() {
}


void MethodArgument::__set_type(const std::string& val) {
  this->type = val;
}

void MethodArgument::__set_name(const std::string& val) {
  this->name = val;
}
std::ostream& operator<<(std::ostream& out, const MethodArgument& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MethodArgument::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MethodArgument::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MethodArgument");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MethodArgument &a, MethodArgument &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

MethodArgument::MethodArgument(const MethodArgument& other31) {
  type = other31.type;
  name = other31.name;
  __isset = other31.__isset;
}
MethodArgument::MethodArgument( MethodArgument&& other32) {
  type = std::move(other32.type);
  name = std::move(other32.name);
  __isset = std::move(other32.__isset);
}
MethodArgument& MethodArgument::operator=(const MethodArgument& other33) {
  type = other33.type;
  name = other33.name;
  __isset = other33.__isset;
  return *this;
}
MethodArgument& MethodArgument::operator=(MethodArgument&& other34) {
  type = std::move(other34.type);
  name = std::move(other34.name);
  __isset = std::move(other34.__isset);
  return *this;
}
void MethodArgument::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MethodArgument(";
  out << "type=" << to_string(type);
  out << ", " << "name=" << to_string(name);
  out << ")";
}


MethodDescription::~MethodDescription() throw() {
}


void MethodDescription::__set_returnType(const std::string& val) {
  this->returnType = val;
}

void MethodDescription::__set_name(const std::string& val) {
  this->name = val;
}

void MethodDescription::__set_arguments(const std::vector<MethodArgument> & val) {
  this->arguments = val;
}
std::ostream& operator<<(std::ostream& out, const MethodDescription& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MethodDescription::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->returnType);
          this->__isset.returnType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arguments.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->arguments.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += this->arguments[_i39].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arguments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MethodDescription::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MethodDescription");

  xfer += oprot->writeFieldBegin("returnType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->returnType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arguments.size()));
    std::vector<MethodArgument> ::const_iterator _iter40;
    for (_iter40 = this->arguments.begin(); _iter40 != this->arguments.end(); ++_iter40)
    {
      xfer += (*_iter40).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MethodDescription &a, MethodDescription &b) {
  using ::std::swap;
  swap(a.returnType, b.returnType);
  swap(a.name, b.name);
  swap(a.arguments, b.arguments);
  swap(a.__isset, b.__isset);
}

MethodDescription::MethodDescription(const MethodDescription& other41) {
  returnType = other41.returnType;
  name = other41.name;
  arguments = other41.arguments;
  __isset = other41.__isset;
}
MethodDescription::MethodDescription( MethodDescription&& other42) {
  returnType = std::move(other42.returnType);
  name = std::move(other42.name);
  arguments = std::move(other42.arguments);
  __isset = std::move(other42.__isset);
}
MethodDescription& MethodDescription::operator=(const MethodDescription& other43) {
  returnType = other43.returnType;
  name = other43.name;
  arguments = other43.arguments;
  __isset = other43.__isset;
  return *this;
}
MethodDescription& MethodDescription::operator=(MethodDescription&& other44) {
  returnType = std::move(other44.returnType);
  name = std::move(other44.name);
  arguments = std::move(other44.arguments);
  __isset = std::move(other44.__isset);
  return *this;
}
void MethodDescription::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MethodDescription(";
  out << "returnType=" << to_string(returnType);
  out << ", " << "name=" << to_string(name);
  out << ", " << "arguments=" << to_string(arguments);
  out << ")";
}


ByteCodeObject::~ByteCodeObject() throw() {
}


void ByteCodeObject::__set_name(const std::string& val) {
  this->name = val;
}

void ByteCodeObject::__set_byteCode(const std::string& val) {
  this->byteCode = val;
}
std::ostream& operator<<(std::ostream& out, const ByteCodeObject& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ByteCodeObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->byteCode);
          this->__isset.byteCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ByteCodeObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ByteCodeObject");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->byteCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ByteCodeObject &a, ByteCodeObject &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.byteCode, b.byteCode);
  swap(a.__isset, b.__isset);
}

ByteCodeObject::ByteCodeObject(const ByteCodeObject& other45) {
  name = other45.name;
  byteCode = other45.byteCode;
  __isset = other45.__isset;
}
ByteCodeObject::ByteCodeObject( ByteCodeObject&& other46) {
  name = std::move(other46.name);
  byteCode = std::move(other46.byteCode);
  __isset = std::move(other46.__isset);
}
ByteCodeObject& ByteCodeObject::operator=(const ByteCodeObject& other47) {
  name = other47.name;
  byteCode = other47.byteCode;
  __isset = other47.__isset;
  return *this;
}
ByteCodeObject& ByteCodeObject::operator=(ByteCodeObject&& other48) {
  name = std::move(other48.name);
  byteCode = std::move(other48.byteCode);
  __isset = std::move(other48.__isset);
  return *this;
}
void ByteCodeObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ByteCodeObject(";
  out << "name=" << to_string(name);
  out << ", " << "byteCode=" << to_string(byteCode);
  out << ")";
}


APIResponse::~APIResponse() throw() {
}


void APIResponse::__set_code(const int8_t val) {
  this->code = val;
}

void APIResponse::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const APIResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t APIResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t APIResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("APIResponse");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(APIResponse &a, APIResponse &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

APIResponse::APIResponse(const APIResponse& other49) {
  code = other49.code;
  message = other49.message;
  __isset = other49.__isset;
}
APIResponse::APIResponse( APIResponse&& other50) {
  code = std::move(other50.code);
  message = std::move(other50.message);
  __isset = std::move(other50.__isset);
}
APIResponse& APIResponse::operator=(const APIResponse& other51) {
  code = other51.code;
  message = other51.message;
  __isset = other51.__isset;
  return *this;
}
APIResponse& APIResponse::operator=(APIResponse&& other52) {
  code = std::move(other52.code);
  message = std::move(other52.message);
  __isset = std::move(other52.__isset);
  return *this;
}
void APIResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "APIResponse(";
  out << "code=" << to_string(code);
  out << ", " << "message=" << to_string(message);
  out << ")";
}

} // namespace
